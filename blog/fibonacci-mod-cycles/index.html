<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fibonacci Mod Cycles.</title>
    <meta name="description" content="Representing Fibonacci sequences as Directed Graphs.">
    <link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/prism.css">
  </head>
  <body>
    <header>
      <h1 class="home">
        <a href="/">Rupert &#39;fildon&#39; McKay</a>
      </h1>
    </header>
    <article>
  <h2>Fibonacci Mod Cycles.</h2>
  <p>The <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci Numbers</a> are a sequence starting, <code>0, 1, 1,...</code>, and each subsequent number being computed as the sum of the previous two.</p>
<p>We could define this in pseudocode:</p>
<pre class="language-ts"><code class="language-ts"><span class="token function">getNthFibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token keyword">is</span> <span class="token number">0</span> or <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token function">getNthFibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><br>    <span class="token operator">+</span> <span class="token function">getNthFibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>When inspecting the sequence of numbers this outputs <em>and in particular</em> the digits of these numbers, we can observe some repeating cycles. However the choice of base number system affects the digits we will see. In order to generalize this independent of base number system, we can inspect the sequence under some modulo. The digits we see in base ten correspond to the sequence under a modulo of power ten.</p>
<p>We can prove that under any modulo, <em>the values must repeat after some finite number of steps</em>.</p>
<h2>Cycles under modulo arithmetic</h2>
<p>I would try to 'formally' prove this, but it's been so long since I've had to formally prove anything that my tools for doing so are rusty. Consider the following a sketch of what a formal proof might look like:</p>
<p>Considering the Fibonacci sequence under modulo <code>k</code>, we can model the 'state' of the sequence at any point as a pair of values corresponding to the previous value and the current value.</p>
<p>Define a directed graph having nodes corresponding to such pairs. Let each node have exactly one outbound edge pointing to the state that comes next in the Fibonacci sequence under the modulo <code>k</code>. For example the 'state' with previous value <code>2</code> and current value <code>3</code> under modulo <code>10</code> will have a single outbound edge to the next state which has previous value <code>3</code> and current value <code>5</code>.</p>
<p>By repeatedly following outbound edges, we can trace a path through the graph. At each node there is exactly one following node. This excludes the possibility of dead ends (which could only happen if there were 0 outbound edges on a given node) or of branching points (which could only happen if there were strictly more than 1 outbound edges on a given node). Additionally we know that the total number of nodes is finite. Given these statements in combination, it must be that we eventually revisit nodes we have seen before.</p>
<p>We can also assert that every node has exactly one inbound node. This is trickier to prove, but can be demonstrated by observing that the mapping from one node to the next is bijective. It can also be seen by rearranging the definition of Fibonacci numbers to work &quot;backwards&quot;, i.e. given two adjacent values in the Fibonacci sequence, you can deduce the value immediately prior to that pair. This is left as an exercise to the reader.</p>
<p>So we now have:</p>
<ul>
<li>There are finitely many nodes.</li>
<li>Every node has exactly one outbound edge.</li>
<li>Every node has exactly one inbound edge.</li>
</ul>
<p>This is sufficient to conclude that every path traced from any node forms a <a href="https://en.wikipedia.org/wiki/Cycle_%28graph_theory%29">cycle</a>.</p>
<p>Indeed every node and every edge is a member of exactly one cycle.</p>
<p>Therefore the resulting graph is a disjoint union of cycles.</p>
<p><strong>QED</strong> <em>maybe?</em></p>
<h2>Examples</h2>
<p>For each of the following diagrams the canonical starting state <code>1, 1</code> is circled.</p>
<h3>Modulo 2</h3>
<p>This is equivalent to inspecting the least siginificant digit, when using base 2.</p>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 2</summary>
  <img src="../../static/fibmod02.svg" alt="Diagram of fibonacci graph under modulo 2" />
</details>
<h3>Modulo 3</h3>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 3</summary>
  <img src="../../static/fibmod03.svg" alt="Diagram of fibonacci graph under modulo 3" />
</details>
<h3>Modulo 4</h3>
<p>This is the first one for which the canonical cycle is not strictly the longest.</p>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 4</summary>
  <img src="../../static/fibmod04.svg" alt="Diagram of fibonacci graph under modulo 4" />
</details>
<h3>Modulo 5</h3>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 5</summary>
  <img src="../../static/fibmod05.svg" alt="Diagram of fibonacci graph under modulo 5" />
</details>
<h3>Modulo 6</h3>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 6</summary>
  <img src="../../static/fibmod06.svg" alt="Diagram of fibonacci graph under modulo 6" />
</details>
<h3>Modulo 7</h3>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 7</summary>
  <img src="../../static/fibmod07.svg" alt="Diagram of fibonacci graph under modulo 7" />
</details>
<h3>Modulo 8</h3>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 8</summary>
  <img src="../../static/fibmod08.svg" alt="Diagram of fibonacci graph under modulo 8" />
</details>
<h3>Modulo 9</h3>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 9</summary>
  <img src="../../static/fibmod09.svg" alt="Diagram of fibonacci graph under modulo 9" />
</details>
<h3>Modulo 10</h3>
<details>
  <summary><strong>[Click to expand]</strong> Fibonacci numbers under mod 10</summary>
  <img src="../../static/fibmod10.svg" alt="Diagram of fibonacci graph under modulo 10" />
</details>
<h2>Other Sequences</h2>
<p>One might wonder whether other numeric sequences could be made to produce graphs in a similar way. It's not immediately clear to me what the set of all sequences we can do this to looks like. But perhaps we can consider some examples.</p>
<p>For an example which <em>could not</em> be graphed in this way, consider the sequence of prime numbers. Under some modulo <code>k</code>, we can't <em>in general</em> know which digits will come next. We require the whole value of the current prime number to be able to determine the next prime. We might instead alter the process slightly to have the output of a given node split multiple ways corresponding to the set of all <em>possible</em> subsequent digits. An especially simple case of this would be considering prime numbers under modulo 2.</p>
<p><img src="../../static/primemod02.svg" alt="Diagram of primary numbers under modulo 2"></p>
<p>After the prime <code>2</code> every later primary is an odd number, hence we continues to be stuck on the <code>1</code> forever more.</p>
<p>However I do not know of a systematic way to produce the diagram for any modulo higher than 2. We might expect the modulo 3 to be the next easiest, but I'm at a loss to reason about the set of all possible adjacencies. Instead I'm left resorting to manually iterating through prime numbers until such a time as I consistently fail to find new edges. However I am unable to exclude the possibility of edges turning up later.</p>
<p>I can automate this somewhat using the following code:</p>
<details>
  <summary><strong>[Click to expand]</strong> Code for generating prime mod edges</summary>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * @returns an array of all primes from 2 up to<br> * and including `bound`<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">generatePrimesUpTo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>bound<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token comment">// Sieve of Eratosthenes</span><br><br>  <span class="token comment">// An array of integers from 2 to bound inclusive</span><br>  <span class="token keyword">const</span> primeCandidates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>bound <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token operator">:</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> isPrime<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Little hack to 'pretend' our indexes start at 2</span><br>  <span class="token keyword">const</span> <span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> primeCandidates<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Any divisor larger than this is irrelevant</span><br>  <span class="token keyword">const</span> largestDivisor <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>bound<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> divisor <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> divisor <span class="token operator">&lt;=</span> largestDivisor<span class="token punctuation">;</span> divisor<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// We don't care about non-prime divisors</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">get</span><span class="token punctuation">(</span>divisor<span class="token punctuation">)</span><span class="token punctuation">.</span>isPrime<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Mark all multiples of this divisor as not prime</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> multiple <span class="token operator">=</span> divisor <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span> multiple <span class="token operator">&lt;=</span> bound<span class="token punctuation">;</span> multiple <span class="token operator">+=</span> divisor<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token function">get</span><span class="token punctuation">(</span>multiple<span class="token punctuation">)</span><span class="token punctuation">.</span>isPrime <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">return</span> primeCandidates<br>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> isPrime <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> isPrime<span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Modulo helper, curried to make a neat pipeline<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">mod</span> <span class="token operator">=</span> <span class="token punctuation">(</span>modulo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> value <span class="token operator">%</span> modulo<span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Given an array of values,<br> * return the set of edges defined by adjacent values<br> *<br> * Edges are formatted as a string<br> * compatible with Mermaid syntax<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">extractEdges</span> <span class="token operator">=</span> <span class="token punctuation">(</span>values<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set<span class="token operator">&lt;</span>`$<span class="token punctuation">{</span><span class="token builtin">number</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">></span></span>$<span class="token punctuation">{</span><span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">>();<br><br>  for (let i = 1; i &lt; values.length; i++) {<br>    edges.add(</span><span class="token template-punctuation string">`</span></span>$<span class="token punctuation">{</span>values<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">></span>$<span class="token punctuation">{</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>`<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">return</span> edges<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> primes <span class="token operator">=</span> <span class="token function">generatePrimesUpTo</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// console.log(primes);</span><br><br><span class="token keyword">const</span> moddedPrimes <span class="token operator">=</span> primes<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">mod</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// console.log(moddedPrimes);</span><br><br><span class="token keyword">const</span> edges <span class="token operator">=</span> <span class="token function">extractEdges</span><span class="token punctuation">(</span>moddedPrimes<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// console.log(edges);</span><br><br><span class="token keyword">const</span> allTogether <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>edges<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>allTogether<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</details>
<p><a href="https://www.typescriptlang.org/play?#code/PQKhCgAIUgBAnApgFwK7wHYGdIEMN7zy4CekA9gGZ4A2NkADvAJYC2iOl85rkATJFQNIycngwATSMwwBjGqgkyA5pAAGAI3KpJaqCGDhZ5bMkjLEGRMWSIACi3ZYAqgwAqYgLyQAFFp0SAFyQGKisGtYAlJCeAHyQAN5QkMDAkADKzIgAbogU1ACiNuRYyAAWlhzgyamQDuQSqLJ5+ITEZFTSGLYW8JzcvAKikP6SXfKoWMy5ycamjI6IAML4ShK4tjjeVgDukACCRKR+2mMAtJAAjJEAdJTMdD6hdLesuAw+PgD6ADTS0XFfAlINlcApEMFmJAANT8P7MLAONgQkTwVCIAC+kUiAG5qpAUmkADLMZDIGh5Mq4WQAaxEYgA5EwUJYJAyKOguhJEAAPDiQUq4eBmDb8WYmUrmFArSTMda2GK+DDBULhKIxeJMZEytYbDgAbQIFz4AF08TU0vsMGQlNkEeR4JAaELeiIqQRygjIDsHvRKLgHvTILyJtzxGQMCYzlqnOL5s74BZSgAlRAU0HdAAi03tju8AFkNmUblgAI7Ck4BXH4yCUB2+ClmW25xV8HGQZtYesAHm8CaTyFT6fwyGzdq78HbnYd0Oh0SSBIJtQA6nkJCYGWZZEKWv4zJGMNHFh2cxOsMkCcxqD4AIQWZA6uV6nzT+C3BFI9jRObIGTo82LoSkCFvAdJgvQrCoDQv4MBSOCdJ6OCvngOCRmYMaIBetb1j4jaQJB0HMLBeTeMhYD8O2BEwRSkC9iMpwSJRUHUXk0KkaeDrzlhBL3o+8qID4VFERS76Ise3j+jQWCIHigEYsk8nJEgaCYAs2qrE+mxYXcDy2PAnzAh+x5Yhq0hicikTaW8Hw+MCoLgpAJmAvZ6LVhi5qgBA0DAQ0UFiBUNAMNYfyyOgLCIFIwxvDSeQMLgWBTBgqgyMMaiHO0NxMOQojICQQU3NZajBvFJD6IYcySqwDSKoJvk0OQKphBEb6mT4LkoqqzUAvE7WQAApPhdXkB5YD6JAADi0yWOIbSkPkIJguiWB-Mp6AehUAooPNEVJh2iD3FYUgaGQuASAAVtSlhmO157eWNBQSLtO7YfAbxkhFKF4AKyAsElkDGKwcW-hoNE+uUwHWG8coCiQ3S4DyZVGBKZi8j91LIA9u3eG1i0cME6WkN2nXWLE3WJHGko7fy2yIHs6QoN2agACQJMT8AYmcZyxCzbPuWosQ+NWyR1o6uFbVC3iXO2ULdgt4JYDcFJJeU0uzlxgFUwrp0SD4zMJDd+pQhclwmhzXMswbzCmziajVgSikEqtqma3iikVehixbFKVg2PYnuuB4PiXAADKHofVrUFXkBSivkMoPgYVgQvu4NEjchIn7U2pTgFe8tU6wAzNieKRxK0eILH8dVWnEWZ0n5op5riqo8QsgY49HD5+ndcR2kUcx-V8ea8nyO0DQHj3hUeaQPqNxz5rJo3Gd5AyD4DIADoYAy1b9xXg8+OBE8oFP1ZAA">TypeScript playground for generating primary number modulo edges</a></p>
<p>We can use this to generate diagrams... however I can't emphasise enough that I cannot prove these diagrams are complete.</p>
<h3>Primes under modulo 3</h3>
<p>I think this one <em>in particular</em> can be proven to be complete. The node <code>0 mod 3</code> is only visited once, by the prime <code>3</code>. It is immediately preceded by <code>2</code> and followed by <code>5</code> which is congruent to <code>2 mod 3</code>. Hence we see the <code>0</code> node connect only to <code>2</code>. However the other two nodes are fully connected to one another and themselves. No additional edges could ever appear.</p>
<p><img src="../../static/primemod03.svg" alt="Diagram of primary numbers under modulo 3"></p>
<h3>Primes under modulo 4</h3>
<p>This one might also be provable complete. The <code>2</code> node is visited only once by the first prime <code>2</code>. It is never returned to since any such value would need to be an even prime large than <code>2</code>, yet no number can possibly exist. All other nodes are fully connected to each other and themselves.</p>
<p><img src="../../static/primemod04.svg" alt="Diagram of primary numbers under modulo 4"></p>
<h3>Primes under modulo 5</h3>
<p>And now I have no idea what the hell is going on.</p>
<p><img src="../../static/primemod05.svg" alt="Diagram of primary numbers under modulo 5"></p>
<h3>Primes under modulo 6</h3>
<p><img src="../../static/primemod06.svg" alt="Diagram of primary numbers under modulo 6"></p>
<h3>Primes under modulo 7</h3>
<p>Cool cool...</p>
<p><img src="../../static/primemod07.svg" alt="Diagram of primary numbers under modulo 7"></p>
<p>Best I can guess is that for any given modulo, the presence of nodes and their edges is related to whether the given node is coprime with the modulo. Certainly the prime modulos seem especially connected.</p>
<p>To investigate this hypothesis, let's jump ahead to 12, since it has many factors. We might therefore expect to see a less chaotic structure.</p>
<h3>Primes under modulo 12</h3>
<p><img src="../../static/primemod12.svg" alt="Diagram of primary numbers under modulo 12"></p>
<p>🤷 I can't tell if I'm on to anything here.</p>
<h2>Conclusions</h2>
<p>Honestly don't know. It seems that with the examples provided of Fibonacci numbers and primary numbers, we see very different outcomes. It remains unclear to me whether these outcomes are unique to these two sequences, or whether there might exist families of sequences with common properties.</p>

</article>
  </body>
</html>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting in JavaScript.</title>
    <meta name="description" content="Typical use-cases and rare edge-cases.">
    <link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/prism.css">
  </head>
  <body>
    <header>
      <h1 class="home">
        <a href="/">Rupert &#39;fildon&#39; McKay</a>
      </h1>
    </header>
    <pre aria-hidden="true">
█ ███ █
███ ███
    </pre>
    <article>
  <h2>Sorting in JavaScript.</h2>
  <p>JavaScript arrays have a builtin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">sort</a> method, which mostly does what you expect:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4]</span><br><span class="token punctuation">[</span><span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['a', 'b', 'c', 'd']</span></code></pre>
<p>But it has some quirks. For example: numbers are sorted <em>as though they were strings</em>, which is fine as long as all your numbers are the same length, but leads to unexpected behavior for numbers of different lengths:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 10, 2] Not what we wanted!</span></code></pre>
<p>Likewise, the default ordering of strings is <em>usually</em> OK, but can be unexpected in the case of non-ASCII characters, for example, letters with accents:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token string">"ä"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['b', 'c', 'ä' ] Maybe not what we wanted?</span></code></pre>
<p>Additionally, the sorting is done <em>in place</em>. That means the original array is modified. Be sure that when you sort an array that modification doesn't have any side effects elsewhere.</p>
<h2 id="primitive-sort-comparators" tabindex="-1"><a class="direct-link" href="#primitive-sort-comparators" aria-hidden="true">#</a> Primitive sort comparators</h2>
<p>Fortunately, we can fix this by always providing an explicit comparator. To do this we pass a callback as an argument to the sort method. For numbers, we can use subtraction to get correct numerical ordering:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 10] That's better!</span></code></pre>
<p>This is necessary because in general JavaScript doesn't know <em>how</em> you want your array to be ordered. You can think of your comparator callback then as being the answer to &quot;Given any two items from the array, how should they <em>compare</em> to each other in the order you want?&quot;. The value returned from your callback must be a number where:</p>
<ul>
<li>if <code>a</code> should come before <code>b</code> then return a negative value</li>
<li>if <code>a</code> should come after <code>b</code> then return a positive value</li>
<li>if <code>a</code> and <code>b</code> are of the same order then return zero</li>
</ul>
<p>This is the minimum necessary information to define the desired ordering.</p>
<p>For strings we can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare"><code>String.prototype.localeCompare</code></a></p>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token string">"ä"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['ä', 'b', 'c']</span></code></pre>
<p>Additionally, you can pass a specific locale since some locales sort differently to others:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// German</span><br><span class="token punctuation">[</span><span class="token string">"ä"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token string">"de"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['ä', 'b', 'c']</span><br><br><span class="token comment">// Swedish</span><br><span class="token punctuation">[</span><span class="token string">"ä"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token string">"sv"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['b', 'c', 'ä']</span></code></pre>
<p>Reference <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare#using_options">localeCompare#using_options</a></p>
<h2 id="sorting-objects-by-property" tabindex="-1"><a class="direct-link" href="#sorting-objects-by-property" aria-hidden="true">#</a> Sorting objects by property</h2>
<p>So we can sort numbers and strings... but what about objects? For an array of objects we typically need to use some property of the object as part of the comparator. For example if we had some array of books, we might want to sort by publication date or by title:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> sortedByDate <span class="token operator">=</span> books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>published <span class="token operator">-</span> b<span class="token punctuation">.</span>published<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> sortedByTitle <span class="token operator">=</span> books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>title<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Note that actually doing both sorts like this side by side would cause the second one to overwrite the first one because sorting is done <em>in place</em> as mentioned earlier.</p>
<p>We can get around this by duplicating the array:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> sortedByDate <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>books<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>published <span class="token operator">-</span> b<span class="token punctuation">.</span>published<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> sortedByTitle <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>books<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>title<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="sorting-by-ascending-or-descending" tabindex="-1"><a class="direct-link" href="#sorting-by-ascending-or-descending" aria-hidden="true">#</a> Sorting by ascending or descending</h2>
<p>Switching between ascending or descending is as simple as inverting the order of <code>a</code> and <code>b</code> in our comparator. For example:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 10] ascending order</span><br><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [10, 2, 1] descending order</span><br><br>books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>published <span class="token operator">-</span> b<span class="token punctuation">.</span>published<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ascending by publication date</span><br>books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> b<span class="token punctuation">.</span>published <span class="token operator">-</span> a<span class="token punctuation">.</span>published<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// descending by publication date</span></code></pre>
<h2 id="sorting-by-multiple-properties" tabindex="-1"><a class="direct-link" href="#sorting-by-multiple-properties" aria-hidden="true">#</a> Sorting by multiple properties</h2>
<p>Often sorting by just one property is not enough. We might need a tiebreaker for items that would otherwise be sorted 'equally'. Consider for example our book collection which we want to sort by author, but then what about multiple books by the same author? I think it would be sensible to use the title as a tiebreaker. This way if you were looking for a particular book by a particular author, you could find it easily first by author then by title.</p>
<p>One way to do this is by relying on the short-circuiting behavior of the <code>||</code> (OR) operator.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> sortedBooks <span class="token operator">=</span> books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">return</span> a<span class="token punctuation">.</span>author<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token operator">||</span> a<span class="token punctuation">.</span>title<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>This works by first checking author's name. If they are different, then that value will be used right away. But if they are the same, then the value will be zero, and since zero is falsey then the right half of the expression will be used instead. So taken together, books will be sorted by author, but within a given author, books will be sorted by title.</p>
<p>This pattern is perfectly fine for a single fallback, and could even be extended to support more fallbacks:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Compare by author first, then by title, and finally by edition number</span><br><span class="token keyword">const</span> sortedBooks <span class="token operator">=</span> books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">return</span> <span class="token punctuation">(</span><br>		a<span class="token punctuation">.</span>author<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token operator">||</span><br>		a<span class="token punctuation">.</span>title<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token operator">||</span><br>		a<span class="token punctuation">.</span>edition <span class="token operator">-</span> b<span class="token punctuation">.</span>edition<br>	<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>But you might also like to abstract this out to a reusable utility that takes a collection of comparators and uses them one after the other until it finds a non-zero result:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> multiSort <span class="token operator">=</span><br>	<span class="token operator">&lt;</span>Item<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">...</span>comparators<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Item<span class="token punctuation">,</span> b<span class="token operator">:</span> Item<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token punctuation">(</span>a<span class="token operator">:</span> Item<span class="token punctuation">,</span> b<span class="token operator">:</span> Item<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>		<span class="token comment">// Try each comparator in turn</span><br>		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> comparator <span class="token keyword">of</span> comparators<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>			<span class="token comment">// Get its result</span><br>			<span class="token keyword">const</span> comparatorResult <span class="token operator">=</span> <span class="token function">comparator</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><br>			<span class="token comment">// Return that result only if it is non-zero</span><br>			<span class="token keyword">if</span> <span class="token punctuation">(</span>comparatorResult <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> comparatorResult<span class="token punctuation">;</span><br>		<span class="token punctuation">}</span><br>		<span class="token comment">// All comparators returned zero, so these items cannot be distinguished</span><br>		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><br>	<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>We can then use this like so:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> sortedBooks <span class="token operator">=</span> books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><br>	<span class="token function">multiSort</span><span class="token punctuation">(</span><br>		<span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>title<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">,</span><br>		<span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>published <span class="token operator">-</span> b<span class="token punctuation">.</span>published<br>	<span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Which makes it quick and easy to rearrange or add and remove comparators. We could also pull out the comparators and test them in isolation if we wanted to.</p>
<h2 id="ways-to-get-it-wrong" tabindex="-1"><a class="direct-link" href="#ways-to-get-it-wrong" aria-hidden="true">#</a> Ways to get it wrong</h2>
<p>One time at a previous company I had a failing test on my machine, but no one else got the same test failure. The test failure corresponded to a snapshotted array sort output. After a lot of trial and error it turned out it was because I was running a different version of Node. But why would the version of Node affect the output of a sorting operation? The sort comparator being used was doing something rather naughty, but unfortunately common. It looked something like this:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Sort users by name, but put all nameless users at the end.</span><br>users<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token comment">// If a doesn't have a name...</span><br>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ...then a should go after b</span><br>	<span class="token comment">// If b doesn't have a name...</span><br>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ...then b should go after a</span><br>	<span class="token comment">// Otherwise compare by name</span><br>	<span class="token keyword">return</span> a<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Can you spot the mistake in this logic? What happens when both a and b do not have a name? Then this comparator declares that a should go before b, but that is not correct, they should be treated as equal. In general, you should avoid checking something about one of the values and not the other. Formally speaking this comparator breaks the <em>antisymmetric</em> property of a total order. Which is a fancy way of saying &quot;it's bad&quot;.</p>
<p>The mathematical concept of a <a href="https://en.wikipedia.org/wiki/Total_order">total order</a> is what defines whether an ordering is consistent. It consists of four rules:</p>
<ol>
<li><code>a &lt;= a</code> (<em>reflexive</em>)</li>
<li>if <code>a &lt;= b</code> and <code>b &lt;= c</code> then <code>a &lt;= c</code> (<em>transitive</em>)</li>
<li>if <code>a &lt;= b</code> and <code>b &lt;= a</code> then <code>a = b</code> (<em>antisymmetric</em>)</li>
<li><code>a &lt;= b</code> or <code>b &lt;= a</code> (<em>strongly connected</em>)</li>
</ol>
<p>These rules are applied in the context of what's called a binary relation, which is a fancy way of defining some relationship between every pair in a set. When dealing with sorting in JavaScript though, we already get rule 1 and 4 for free as long as you always return <em>anything</em> from your comparator. But rules 2 and 3 can potentially be violated.</p>
<p>As we saw in the example above we can violate the <em>antisymmetric</em> rule by only checking one value before returning.</p>
<p>Violating the <em>transitive</em> rule is a little harder but can happen under rare circumstances. Consider for example trying to sort which of Rock, Paper, Scissors is the &quot;best&quot; move to play. You might try to do this by comparing values directly in terms of which one beats others:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">sortByWinner</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token comment">// If a beats b, then a should go first</span><br>	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">beats</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><br>	<span class="token comment">// If b beats a, then b should go first</span><br>	<span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">beats</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><br>	<span class="token comment">// Neither beats the other, so these two are equal</span><br>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Although there is no obvious mistake in this code, it nonetheless will result in inconsistent ordering. Unfortunately, there is no way to fix this. Fundamentally the property we are trying to sort by is <em>intransitive</em> and this is not so much a mistake in the code, as it is in the underlying assumptions we make in trying to sort by this property at all. It simply is not a property we can use to sort.</p>
<h2 id="how-to-get-it-right" tabindex="-1"><a class="direct-link" href="#how-to-get-it-right" aria-hidden="true">#</a> How to get it right</h2>
<p>We've seen how the example above got it wrong by treating <code>a</code> preferentially, but how would we do this correctly? It's quite a fiddly thing to do right, since either <code>a</code> or <code>b</code> might not have a name, so we need to elegantly handle comparison by string only if they both have a name. If either doesn't have a name, then we need to be careful to consider both <code>a</code> and <code>b</code> and compare them based simply on whether they have a name or not.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Sort users by name, but nameless users should go at the end</span><br>users<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token comment">// Both users have a name, so compare directly</span><br>	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>name <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>	<span class="token comment">// Otherwise we sort by having a name or not</span><br>	<span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>b<span class="token punctuation">.</span>name <span class="token operator">-</span> <span class="token operator">!</span><span class="token operator">!</span>a<span class="token punctuation">.</span>name<span class="token punctuation">;</span><br>	<span class="token comment">// b goes first because we want names first, non-names second</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Notice how in this revised version we now treat <code>a</code> and <code>b</code> equally. Anything we do to one we do to the other.</p>
<p>In general, to consistently write correct comparators we should try to follow these general rules:</p>
<ul>
<li>Always treat <code>a</code> and <code>b</code> equally</li>
<li>Use subtraction for numbers</li>
<li>Use <code>localeCompare</code> for strings</li>
<li>Check that it is OK to modify the array before sorting</li>
<li>In rare cases, a property is logically incompatible with the concept of ordering</li>
</ul>
<p>Take care,</p>
<p>Rupert</p>

</article>
  </body>
</html>
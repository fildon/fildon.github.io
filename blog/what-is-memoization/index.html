<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What is memoization?</title>
    <meta name="description" content="An introduction to Memoization and how to use it.">
    <link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/prism.css">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">Rupert &#39;fildon&#39; McKay</a></h1>
    </header>
    <main>
      <article class="stack">
  <h2>What is memoization?</h2>
  <p>Imagine I asked you to calculate 23 times 47. And let's imagine you don't have a calculator or your phone on you, so you have to do it the hard way using just a pencil and paper. Your working might look something like this:</p>
<blockquote>
<p>23 * 47</p>
<p>= 20 * 47 + 3 * 47</p>
<p>= 940 + 120 + 21</p>
<p>= 1081</p>
</blockquote>
<p>Great! You worked it out. But it wasn't fun and it wasn't easy. So if later I ask you again &quot;What is 23 times 47?&quot;, you really don't want to have to do that calculation again. Fortunately, you still have the answer written down from last time, so you can just look at the bottom of the paper and say &quot;1081&quot; triumphantly.</p>
<p><em>That is memoization</em>.</p>
<blockquote>
<p>Memoization is the process of &quot;remembering&quot; the results of previous computations, which can be reused in the future.</p>
</blockquote>
<h2>What shouldn't be memoized?</h2>
<p>Unfortunately, not every kind of computation is suitable for memoization.</p>
<blockquote>
<p>Very cheap functions</p>
</blockquote>
<p>Imagine I ask you &quot;What's 1+1?&quot;, you can answer &quot;2&quot; immediately. And when I ask you again later, it wouldn't be any faster to try and remember what you did last time... it's quicker just to recompute the answer from scratch since you can do it instantly anyway.</p>
<blockquote>
<p>Non-deterministic functions</p>
</blockquote>
<p>Imagine your friend asks you to think of a random number from 1 to 10. They probably <em>don't want you to</em> give the same answer every time.</p>
<blockquote>
<p>Side-effects</p>
</blockquote>
<p>If a function has any side effects. Your friend now asks you to clean the dishes, and you do so. If the next day they ask you to do it again, it's tempting, but not helpful to say that you did it yesterday. It doesn't matter that you did it previously, <em>you have to do it again</em>.</p>
<blockquote>
<p>Time-dependent</p>
</blockquote>
<p>If a function depends on time in some way. Your friend asks you what time it is. If an hour later they ask again, it would be wrong to repeat the answer you gave last time.</p>
<ul>
<li>1+1 doesn't need to be memoized</li>
<li>Random results shouldn't be memoized</li>
<li>Side effects shouldn't be memoized</li>
<li>Time-dependent shouldn't be memoized</li>
</ul>
<p>Once you've ruled out all of those, you are left with <em>pure functions</em>. By definition, pure functions depend only on their inputs and for a given input, always return the same answer. Pure functions have lots of interesting and useful properties, but today we'll just be talking about memoization.</p>
<h2>Pseudocode</h2>
<blockquote>
<p>Receive input</p>
<p>Check if we have seen this input before</p>
<p>If we have: return the result</p>
<p>If we haven't: compute the result, store it along with the input. Return the result.</p>
</blockquote>
<h2>A First Attempt</h2>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> memoize <span class="token operator">=</span> <span class="token operator">&lt;</span>Input <span class="token keyword">extends</span> <span class="token class-name">PropertyKey</span><span class="token punctuation">,</span> Result<span class="token operator">></span><span class="token punctuation">(</span><br>  <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Input<span class="token punctuation">)</span> <span class="token operator">=></span> Result<br><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token comment">// 'memory' will store previous results</span><br>  <span class="token keyword">const</span> memory<span class="token operator">:</span> Map<span class="token operator">&lt;</span>Input<span class="token punctuation">,</span> Result<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Return the newly memoized function</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Input<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token comment">// If we haven't already seen this 'input'</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>memory<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token comment">// Then call the "real" function and store the result in memory</span><br>      memory<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token function">callback</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Return the result from memory</span><br>    <span class="token keyword">return</span> memory<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAtgUziAlgLwTAvDAPASTAAcBXWBADygTABMIYAFAJxCIWagE8BpBLgDQwASgggkANlAB8ACgBQMGMACGEiQCMVwANYAuGLJTEyBwqSgBKbNJFjJUeday2A3opgB6TzADkiZGYuXxgAdxR1GGgQZkwiWIA3FBASBljxKQgPUEhYAJiuAwBZFSICEyghUQyZbBgwBFCYEqJZSwBueQ9vOygSZjAYKAALTAbQiS54JFQMWhgAMxIwYChksA9YvoHDYwszCuc3DyUe-AWwzGGVBJpfWDVYlVopiAQaIeGUBl89sl8TjAUBdZABCfJBAB01wgRkO1ncSiRXh8ABVRoNVJERpgAERPCS4xbLVbrGAqOhRKAxTA4mDpBxAwYQriApQsyFvKBwixCLGabQ6HlkSwdQEAXy6yJ6om2gzpDKki1YcGmgVZyK2-WZMyhAHMENy-lZQZ0lOLOhb5EA">Try this code out in TypeScript Playground</a></p>
<p>The limitation here is that we can only use this on functions that take a single argument (<code>Input</code>) and that single argument must be something we can use as a key (<code>extends PropertyKey</code>).</p>
<h2>A better way</h2>
<p>If instead, we want to be able to support all kinds of functions, then our memoizer also needs to be provided a way to <em>resolve</em> a given argument list to a property key. We call this a <code>resolver</code>.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> memoize <span class="token operator">=</span> <span class="token operator">&lt;</span>Args <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Result<span class="token operator">></span><span class="token punctuation">(</span><br>  <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Args<span class="token punctuation">)</span> <span class="token operator">=></span> Result<span class="token punctuation">,</span><br>  <span class="token function-variable function">resolver</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Args<span class="token punctuation">)</span> <span class="token operator">=></span> PropertyKey<br><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> memory<span class="token operator">:</span> Map<span class="token operator">&lt;</span>PropertyKey<span class="token punctuation">,</span> Result<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Everything here is the same as above, except...</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Args<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token comment">// ... we invoke the resolver here to get the key we will use for this input</span><br>    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">resolver</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>memory<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      memory<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Return result from memory</span><br>    <span class="token keyword">return</span> memory<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAtgUziAlgLwTAvDAPAQQCcBzCGBADygTABMyBDMATwG0BdAGhgCUEIArgBsoAPgAUAKBgxgDIUIBGDYAGsAXDHEA6XQxIRNRUgEpso3v2FRO0mIX4ghANwSFNOvQaMGzWCwAKhCAADm5QzADSCMySfhYA3nagkLCIyITMmgCyDCG4QaHhUTHcfIIiFjhgCADuMLkh4iYA3JJ2APQdMACirplQABYoYMQwg26YKGRDmBAMiDAMjIogrtyUwAghULradg5QAoRgWnv6pD6m5jBJMjJdMHswtVNgziCqmLP2ji5u40mMCgIBgxAQsB+X2YL0wtRQChgAggmAAZiBCMDhmQRiEBFA7DIUtAYNDsL8IE5+p5tBcIK12vcYChUVoAITpDHMbSDZbiaEmMx3JnwJBc7QoqD80qyeRKFSqGl0wVtJkAX0Z90efCOJwp1hgqOCcFFGViTMOx1OnMy2nBUoFbNVMDVbVdkiAA">Try this code out in TypeScript Playground</a></p>
<p>We can now apply this as a wrapper to any expensive pure function.</p>
<p>At this point, you might be interested to compare this implementation to the implementations offered by Lodash's <a href="https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L10540">memoize</a> and Ramda's <a href="https://github.com/ramda/ramda/blob/v0.28.0/source/memoizeWith.js#L36">memoizeWith</a></p>
<p>Both take the same approach of applying a resolver to get and set results to a key-value store. The only variations I see are that Lodash binds their storage as a property on the returned function, while Ramda <a href="https://en.wikipedia.org/wiki/Currying">curry</a> the whole thing. But otherwise, the essence of all of these implementations are very similar.</p>
<h2>Recursive functions</h2>
<p>While the above approach is perfect for conventional expensive pure functions, it is not all that useful for recursion. Let's consider the classic example of <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> invocationCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Compute the nth fibonacci number<br> */</span><br><span class="token keyword">const</span> fibonacci <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  invocationCounter<span class="token operator">++</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>invocationCounter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21891</span></code></pre>
<p>It takes over 20 thousand invocations to compute just the 20th Fibonacci number!</p>
<p>But what if we pass this through our memoizer?</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> memoFibonacci <span class="token operator">=</span> <span class="token function">memoize</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=></span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">memoFibonacci</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>invocationCounter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21891</span></code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAtgUziAlgLwTAvDAPAQQCcBzCGBADygTABMyBDMATwG0BdAGhgCUEIArgBsoAPgAUAKBgxgDIUIBGDYAGsAXDHEA6XQxIRNRUgEpso3v2FRO0mIX4ghANwSFNOvQaMGzWCwAKhCAADm5QzADSCMySfhYA3nagkLCIyITMmgCyDCG4QaHhUTHcfIIiFjhgCADuMLkh4iYA3HYOUAKEYFq62vqkPqbmMEkyMinQMKox2PaOLm6e-b5t4zAoAGZaAITpIJnaABYMEOIzzCZm+4cQCFDnpbLySiqqywMQV2vjHV09N2Y2mI90elx2PwAvm1oZJJAB6eEwADqCAA5AoYAI7hswM4QHIoChwABhEACMDUQgwKAgGmEN4wI4gepwJjMGkoRBkTYoRTgFTAFAbMhyBQIWiSIT3XH4wnEsBkilUuYABjak1gvP5YEFwpw4jAmjAAjgijcJmNpvN1P8ozsKDxBIYRNJ5MpbgA1J6flstD1cDgAIxmP7dGBBn5hnragXAIWGmAAWgjZk9MFjuvjKETKYATK0ZJJYZJM3rxHnVa1JJMnAhtEIQMRxI65S6FUqPYRC4iYHmgwAOACcQbhmvgSBAADE+XGhXN9ugEOIy9nuD07WBq63na7Fe6VTh1ZJ9jOdeXK9Xa9KG02W075W7lRaWjBe-3h0HtDAAHJ0801LyUA7HCO6Pvuz62jAx6nrOWYJpeGrgBAda3s2YHtk+XY9kiqrfgAQgIsBikIjrEDAtQoFARw0kcmAQAwiC4iEREwAwMB3CktCckxtQHKoECSEAA">Try this in the TypeScript Playground</a></p>
<p>It took <em>exactly the same amount of invocations</em>. We gained zero benefits from memoization!</p>
<p>The problem is that our memoizer only memoizes the top-level call to <code>fibonacci</code>. Since the underlying implementation still calls out to the original <code>fibonacci</code> implementation, those inner calls are not memoized. It will have correctly stored the result of <code>memoFibonacci(20)</code> in memory, so this particular result can be retrieved instantly if we ask it again. But if we change the input to <code>memoFibonacci(19)</code> we get no benefit <em>even though that result was computed as part of the recursive calculation previously</em>.</p>
<p>So ideally we want a way to memoize <code>fibonacci</code> such that every intermediate result gets memoized along the way, <em>not just the top-level call</em>.</p>
<h2>Memoizing Fibonacci</h2>
<p>To more fully memoize <code>fibonacci</code> we have to insert the memoization inside the implementation. The approach here should look very familiar but done in a way that cannot be easily separated out.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> invocationCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> memory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> memoFibonacci <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  invocationCounter<span class="token operator">++</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>memory<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memory<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">memoFibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">memoFibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  memory<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token function">memoFibonacci</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>invocationCounter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 39</span></code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/DYUwLgBAlgdgbgewMYEMxQTAwggrjMEAJwgF4IAGAbgCglMBnSAWxGYSIE8yIYQB3CAFkUABwA8MXMwBGxADS9pcogD4AFAEo6jFmwQAxKDMwokSKD3UwAXEtnFNdqQ5KlVEAN40I0eMjQMbDwCYgBqMNpfKAAzCHVWdi4AOgALFAZrTU0IInBcIhgIRI5OZIBzcCyAQijoOOsIcXIARhy8sAKilrr6GCZckAZcYEhyEqMTGDMLRoBaCDaIMOL9SdNzKHmIACZNOpKUhiqYRTzh0f2fQc7CwYuwWgBfGhoJ4w3ZnYorvoYEUDJYAIcrqWCIVDoTA4fCEIj7CAAekREAAzABOGhAA">Try this in the TypeScript playground</a></p>
<p>This brought the invocations down to just 39. That's a huge performance win. If you are familiar with <a href="https://en.wikipedia.org/wiki/Big_O_notation">O-notation</a>, our initial implementation was <code>O(n^2)</code> whereas now it is just <code>O(n)</code>. But don't worry if you don't know what this means. It is just a fancy way of saying that it is a heck of a lot faster when properly memoized.</p>
<h2>Conclusion</h2>
<ul>
<li>Memoization is suitable for computationally expensive pure functions</li>
<li>Custom implementation is not so difficult, but many libraries also exist</li>
<li>Recursive functions present an additional challenge, but the rewards can be huge</li>
</ul>
<p>Take care,</p>
<p>Rupert</p>

</article>

    </main>
  </body>
</html>

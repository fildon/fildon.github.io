<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advent of Code 2022</title>
    <meta name="description" content="A friendly guide to AoC puzzles.">
    <link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/prism.css">
  </head>
  <body>
    <header>
      <h1 class="home">
        <a href="/">Rupert &#39;fildon&#39; McKay</a>
      </h1>
    </header>
    <pre role="img" aria-label="RM">
â–ˆ â–ˆâ–ˆâ–ˆ â–ˆ
â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ
    </pre>
    <article>
  <h2>Advent of Code 2022</h2>
  <p>Advent of Code is:</p>
<blockquote>
<p>an Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like.</p>
</blockquote>
<p>This blog post will present my solutions and explanations to each puzzle in 2022.</p>
<p>I've hidden each solution inside its own <code>details</code> element, so you won't spoil anything for yourself by just scrolling down.</p>
<p><a href="https://adventofcode.com/2022">Advent of Code 2022</a></p>
<h2 id="day-01-calorie-counting" tabindex="-1"><a class="direct-link" href="#day-01-calorie-counting" aria-hidden="true">#</a> Day 01: Calorie Counting</h2>
<p><a href="https://adventofcode.com/2022/day/1">Day 01 Puzzle Text</a></p>
<p>The elves want to assess how much food they are carrying. To figure this out we have been provided a list of all their food. Each line is either blank or a number of calories for a given food item. The blank lines represent the separator between one elf's inventory and the next.</p>
<details>
  <summary><strong>[Click to expand]</strong> my approach and solution</summary>
<p>So generally I want to add up numbers, but start a new count each time I encounter a blank line.</p>
<p>I chose to model this as an array of numbers, each representing the total calories held by one elf. Rather than append new entries to the end, I push them on to the front since this means the &quot;current&quot; inventory is always the one at the front. This way I avoid needing to fiddle around with array lengths to get the last element in an arary.</p>
<p>To parse our input data into this model, I use a reducer. On each line:</p>
<ul>
<li>If the line is empty: Start a new entry in our model by pushing the value <code>0</code> into the front of the array.</li>
</ul>
<pre class="language-ts"><code class="language-ts"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> currentInventory<span class="token punctuation">,</span> <span class="token operator">...</span>otherInventories<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>If the line is non-empty: Add the value of this line to the &quot;current&quot; inventory by adding its value to the first value in the array.</li>
</ul>
<pre class="language-ts"><code class="language-ts"><span class="token punctuation">[</span>currentInventory <span class="token operator">+</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">...</span>otherInventories<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>Once I have the data in this format, both parts are trivial.</p>
<p>Part 1 wants the largest single value, so I use another reducer to scan the array and hold onto the largest value as it goes.</p>
<pre class="language-ts"><code class="language-ts"><span class="token function">getElfInventories</span><span class="token punctuation">(</span><span class="token function">getInputStrings</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><br>	<span class="token punctuation">(</span>greatest<span class="token punctuation">,</span> elf<span class="token punctuation">)</span> <span class="token operator">=></span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>greatest<span class="token punctuation">,</span> elf<span class="token punctuation">)</span><span class="token punctuation">,</span><br>	<span class="token operator">-</span><span class="token number">Infinity</span><br><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Part 2 wants the sum of the three largest values, so I do a descending sort and slice off the first three values.</p>
<pre class="language-ts"><code class="language-ts"><span class="token function">getElfInventories</span><span class="token punctuation">(</span><span class="token function">getInputStrings</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><br>	<span class="token comment">// Descending sort, puts largest values at the beginning</span><br>	<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=></span> b <span class="token operator">-</span> a<span class="token punctuation">)</span><br>	<span class="token comment">// Take the first/largest three</span><br>	<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><br>	<span class="token comment">// Sum</span><br>	<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span> acc <span class="token operator">+</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://github.com/fildon/AdventOfCode2022/blob/main/src/01-calorie-counting/solutions.ts">Full Day 01 Source Code</a></p>
</details>
<h2 id="day-02-rock-paper-scissors" tabindex="-1"><a class="direct-link" href="#day-02-rock-paper-scissors" aria-hidden="true">#</a> Day 02: Rock Paper Scissors</h2>
<p><a href="https://adventofcode.com/2022/day/1">Day 02 Puzzle Text</a></p>
<p>The elves are going to play a Rock Paper Scissors tournament. But you have a cheatsheet which can guarantee victory.</p>
<p>Each line of the input is a pair of letters representing the move your opponent will play and the move you should play in response.</p>
<p>The elves have their own scoring system for Rock Paper Scissors. Our task is to figure out how much we will score by following the provided cheatsheet.</p>
<details>
  <summary><strong>[Click to expand]</strong> my approach and solution</summary>
<p>This task is a series of lookups.</p>
<ul>
<li>First lookup the move each letter in the input represents</li>
<li>Then lookup the score provided by the move you played</li>
<li>Finally lookup the score provided by the result for that round</li>
</ul>
<p>For part 1, I implemented the three lookups in three different ways, just to amuse myself. The first I use a switch statement, the second an <code>Array.prototype.indexOf</code> and the third a regular object.</p>
<p>First lookup:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * A for Rock, B for Paper, and C for Scissors.<br> * X for Rock, Y for Paper, and Z for Scissors.<br> */</span><br><span class="token keyword">const</span> parseLetter <span class="token operator">=</span> <span class="token punctuation">(</span>letter<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Shape <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">switch</span> <span class="token punctuation">(</span>letter<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>		<span class="token keyword">case</span> <span class="token string">"A"</span><span class="token operator">:</span><br>		<span class="token keyword">case</span> <span class="token string">"X"</span><span class="token operator">:</span><br>			<span class="token keyword">return</span> <span class="token string">"Rock"</span><span class="token punctuation">;</span><br>		<span class="token keyword">case</span> <span class="token string">"B"</span><span class="token operator">:</span><br>		<span class="token keyword">case</span> <span class="token string">"Y"</span><span class="token operator">:</span><br>			<span class="token keyword">return</span> <span class="token string">"Paper"</span><span class="token punctuation">;</span><br>		<span class="token keyword">default</span><span class="token operator">:</span><br>			<span class="token keyword">return</span> <span class="token string">"Scissors"</span><span class="token punctuation">;</span><br>	<span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Second lookup:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * 1 for Rock, 2 for Paper, and 3 for Scissors<br> */</span><br><span class="token keyword">const</span> shapeScore <span class="token operator">=</span> <span class="token punctuation">(</span>shape<span class="token operator">:</span> Shape<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=></span><br>	<span class="token punctuation">[</span><span class="token string">"Rock"</span><span class="token punctuation">,</span> <span class="token string">"Paper"</span><span class="token punctuation">,</span> <span class="token string">"Scissors"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre>
<p>Third lookup:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * 0 if you lost, 3 if the round was a draw, and 6 if you won<br> */</span><br><span class="token keyword">const</span> outcomeScore <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>theirPlay<span class="token punctuation">,</span> myPlay<span class="token punctuation">]</span><span class="token operator">:</span> Round<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">const</span> outcomeMap<span class="token operator">:</span> Record<span class="token operator">&lt;</span>Shape<span class="token punctuation">,</span> Record<span class="token operator">&lt;</span>Shape<span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>		Rock<span class="token operator">:</span> <span class="token punctuation">{</span> Rock<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> Paper<span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span> Scissors<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>		Paper<span class="token operator">:</span> <span class="token punctuation">{</span> Rock<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> Paper<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> Scissors<span class="token operator">:</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>		Scissors<span class="token operator">:</span> <span class="token punctuation">{</span> Rock<span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span> Paper<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> Scissors<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>	<span class="token punctuation">}</span><span class="token punctuation">;</span><br>	<span class="token keyword">return</span> outcomeMap<span class="token punctuation">[</span>theirPlay<span class="token punctuation">]</span><span class="token punctuation">[</span>myPlay<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>For part 2 it is revealed that we need to decrypt the instructions before using them directly. This only slightly changes the behaviour of the first lookup.</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * X means you need to lose,<br> * Y means you need to end the round in a draw,<br> * and Z means you need to win.<br> */</span><br><span class="token keyword">const</span> decryptRound <span class="token operator">=</span> <span class="token punctuation">(</span>line<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Round <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">const</span> <span class="token punctuation">[</span>theirLetter<span class="token punctuation">,</span> myLetter<span class="token punctuation">]</span> <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token keyword">const</span> theirPlay <span class="token operator">=</span> <span class="token function">parseLetter</span><span class="token punctuation">(</span>theirLetter<span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token keyword">const</span> decryptionMap<span class="token operator">:</span> Record<span class="token operator">&lt;</span>Shape<span class="token punctuation">,</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Shape<span class="token operator">>></span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>		Rock<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token operator">:</span> <span class="token string">"Scissors"</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">:</span> <span class="token string">"Rock"</span><span class="token punctuation">,</span> <span class="token constant">Z</span><span class="token operator">:</span> <span class="token string">"Paper"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>		Paper<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token operator">:</span> <span class="token string">"Rock"</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">:</span> <span class="token string">"Paper"</span><span class="token punctuation">,</span> <span class="token constant">Z</span><span class="token operator">:</span> <span class="token string">"Scissors"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>		Scissors<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token operator">:</span> <span class="token string">"Paper"</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">:</span> <span class="token string">"Scissors"</span><span class="token punctuation">,</span> <span class="token constant">Z</span><span class="token operator">:</span> <span class="token string">"Rock"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>	<span class="token punctuation">}</span><span class="token punctuation">;</span><br>	<span class="token keyword">return</span> <span class="token punctuation">[</span>theirPlay<span class="token punctuation">,</span> decryptionMap<span class="token punctuation">[</span>theirPlay<span class="token punctuation">]</span><span class="token punctuation">[</span>myLetter<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://github.com/fildon/AdventOfCode2022/blob/main/src/02-rock-paper-scissors/solutions.ts">Full Day 02 Source Code</a></p>
</details>
<h2 id="day-03-rucksack-reorganization" tabindex="-1"><a class="direct-link" href="#day-03-rucksack-reorganization" aria-hidden="true">#</a> Day 03: Rucksack Reorganization</h2>
<p><a href="https://adventofcode.com/2022/day/3">Day 03 Puzzle Text</a></p>
<p>The elves have loaded up their rucksacks for the journey ahead, but they've made a mistake! Your task is to find the mistakes.</p>
<details>
  <summary><strong>[Click to expand]</strong> my approach and solution</summary>
<p>In part one, we are looking for the letter that appears in the first and last half of each input line. To assist with this I implemented a general purpose duplicate finder. Finding duplicates is equivalent to repeated set intersection.</p>
<p>I implement this by mapping all the containers to sets and then using the intersect function to reduce them all to one set. I then map the result back into an array for convenience.</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Given sets A and B, return the set of their intersection<br> */</span><br><span class="token keyword">const</span> intersect <span class="token operator">=</span> <span class="token operator">&lt;</span>Element<span class="token operator">></span><span class="token punctuation">(</span>a<span class="token operator">:</span> Set<span class="token operator">&lt;</span>Element<span class="token operator">></span><span class="token punctuation">,</span> b<span class="token operator">:</span> Set<span class="token operator">&lt;</span>Element<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=></span> b<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Find all elements that appear in all provided containers<br> */</span><br><span class="token keyword">const</span> findDuplicates <span class="token operator">=</span> <span class="token operator">&lt;</span>Element<span class="token operator">></span><span class="token punctuation">(</span>containers<span class="token operator">:</span> Element<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><br>		containers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>intersect<span class="token punctuation">)</span><br>	<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Other than that we need some boiler plate code to parse the input into &quot;Containers&quot; (arrays of characters) and scoring the duplicates we find according to the elves' system.</p>
<p>Once put together the part 1 solution is a simple pipeline:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">solvePart1</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token function">getInputStrings</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><br>		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toContainers<span class="token punctuation">)</span><br>		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>getRucksackPriority<span class="token punctuation">)</span><br>		<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>For part two we are now looking for duplicates in each group of three input lines. So the only new code we will need is a way to group in batches of three. A reduce will come in handy here. The trick here is treating the head of our accumulator as our &quot;working group&quot; which we push containers into. Once the &quot;working group&quot; has three containers, we start a new group at the head of the accumulator.</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Group containers in batches of three<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">group</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>currentGroup<span class="token punctuation">,</span> <span class="token operator">...</span>otherGroups<span class="token punctuation">]</span><span class="token operator">:</span> Group<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rucksack<span class="token operator">:</span> Container<span class="token punctuation">)</span> <span class="token operator">=></span><br>	currentGroup<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><br>		<span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>rucksack<span class="token punctuation">,</span> <span class="token operator">...</span>currentGroup<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>otherGroups<span class="token punctuation">]</span><br>		<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>rucksack<span class="token punctuation">]</span><span class="token punctuation">,</span> currentGroup<span class="token punctuation">,</span> <span class="token operator">...</span>otherGroups<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>Once again, our solution is now a simple pipeline:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">solvePart2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token function">getInputStrings</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><br>		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toContainers<span class="token punctuation">)</span><br>		<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// Second arg is the initially empty group</span><br>		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>getGroupPriority<span class="token punctuation">)</span><br>		<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://github.com/fildon/AdventOfCode2022/blob/main/src/03-rucksack-reorganization/solutions.ts">Full Day 03 Source Code</a></p>
</details>
<h2 id="day-04-camp-cleanup" tabindex="-1"><a class="direct-link" href="#day-04-camp-cleanup" aria-hidden="true">#</a> Day 04: Camp Cleanup</h2>
<p><a href="https://adventofcode.com/2022/day/4">Day 04 Puzzle Text</a></p>
<p>The elves are cleaning up camp by assigning sections of the camp to clean. However some of the assignments overlap with others. Our task is to find these overlaps so they can avoid duplicating work.</p>
<details>
  <summary><strong>[Click to expand]</strong> my approach and solution</summary>
<p>There's very little logic to do in this puzzle. Most of the work is parsing the input. I chose to parse each line into a pair of pair of numbers. Here's my data type:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Range</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name">RangePair</span> <span class="token operator">=</span> <span class="token punctuation">[</span>Range<span class="token punctuation">,</span> Range<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>To parse each line we first split by <code>,</code> and then by <code>-</code>. Since splitting a string returns an array, I also created a type predicate to narrow from an array to a 2-tuple:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * A little utility to narrow from an array to a tuple of length 2<br> */</span><br><span class="token keyword">const</span> isPair <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>elements<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> elements <span class="token keyword">is</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token punctuation">]</span> <span class="token operator">=></span> elements<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>
<p>This means I now get a little validation on each parsing step:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Parse strings of the form "3-42" to Range<br> */</span><br><span class="token keyword">const</span> toRange <span class="token operator">=</span> <span class="token punctuation">(</span>instruction<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Range <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">const</span> bounds <span class="token operator">=</span> instruction<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPair</span><span class="token punctuation">(</span>bounds<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> bounds<span class="token punctuation">;</span><br>	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Unrecognised instruction: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>instruction<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Parse strings of the form "1-12,3-42" to RangePair<br> */</span><br><span class="token keyword">const</span> toRangePair <span class="token operator">=</span> <span class="token punctuation">(</span>line<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> RangePair <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">const</span> nums <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toRange<span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPair</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">;</span><br>	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Unrecognised line: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>line<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>The only thing remaining is to identify which pairs overlap. This can be done with a oneliner:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Returns true if either range fully overlaps the other<br> */</span><br><span class="token keyword">const</span> fullyOverlaps <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>aStart<span class="token punctuation">,</span> aEnd<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>bStart<span class="token punctuation">,</span> bEnd<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> RangePair<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span><br>	<span class="token punctuation">(</span>aStart <span class="token operator">&lt;=</span> bStart <span class="token operator">&amp;&amp;</span> aEnd <span class="token operator">>=</span> bEnd<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>bStart <span class="token operator">&lt;=</span> aStart <span class="token operator">&amp;&amp;</span> bEnd <span class="token operator">>=</span> aEnd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The left half of that expression handles the case in which <code>a</code> fully overlaps <code>b</code>, and the right half handles the case in which <code>b</code> fully overlaps <code>a</code>.</p>
<p>We now assemble the solution to part 1 as a pipeline:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">solvePart1</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token function">getInputStrings</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toRangePair<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>fullyOverlaps<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span></code></pre>
<p>Part 2 changes only one thing. We are now asked to count any kind of overlap. This requires only a slight modification to our overlapping check. Here's all I had to add for part 2:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Returns true if there is any overlap at all between the two ranges<br> */</span><br><span class="token keyword">const</span> partiallyOverlaps <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><br>	<span class="token punctuation">[</span>aStart<span class="token punctuation">,</span> aEnd<span class="token punctuation">]</span><span class="token punctuation">,</span><br>	<span class="token punctuation">[</span>bStart<span class="token punctuation">,</span> bEnd<span class="token punctuation">]</span><span class="token punctuation">,</span><br><span class="token punctuation">]</span><span class="token operator">:</span> RangePair<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span><br>	<span class="token punctuation">(</span>aStart <span class="token operator">&lt;=</span> bEnd <span class="token operator">&amp;&amp;</span> aEnd <span class="token operator">>=</span> bStart<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>bStart <span class="token operator">&lt;=</span> aEnd <span class="token operator">&amp;&amp;</span> bEnd <span class="token operator">>=</span> aStart<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">solvePart2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token function">getInputStrings</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toRangePair<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>partiallyOverlaps<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span></code></pre>
<p><a href="https://github.com/fildon/AdventOfCode2022/blob/main/src/04-camp-cleanup/solutions.ts">Full Day 04 Source Code</a></p>
</details>
<h2 id="day-05-supply-stacks" tabindex="-1"><a class="direct-link" href="#day-05-supply-stacks" aria-hidden="true">#</a> Day 05: Supply Stacks</h2>
<p><a href="https://adventofcode.com/2022/day/5">Day 05 Puzzle Text</a></p>
<p>The elves are unloading shipping crates with a giant cargo crane. Given the current stacks of crates and a list of crane instructions, our task is to find the end state of the stacks.</p>
<details>
  <summary><strong>[Click to expand]</strong> my approach and solution</summary>
<p>This task has three interesting stages:</p>
<ul>
<li>Decide on an appropriate data structure</li>
<li>Parse the input into our data structure</li>
<li>Execute the crane instructions</li>
</ul>
<p>Our chosen data structure will need a way to represent a collection of stacks, where each stack is itself a collection of crates. Crates are distinguished only by a single letter. An array of arrays of strings will fit the requirements nicely.</p>
<p>We'll also need to represent all the crane instructions. The instructions are a list, where each item has three interesting pieces of information: the quantity, the source stack and the target stack. To me, this screams &quot;array of objects&quot;.</p>
<p>Put together, my data structure is:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Stacks</span> <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">>></span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name">Instruction</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>	qty<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>	from<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>	to<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name">CraneJob</span> <span class="token operator">=</span> <span class="token punctuation">{</span> stacks<span class="token operator">:</span> Stacks<span class="token punctuation">;</span> instructions<span class="token operator">:</span> Instruction<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>The next stage of this task is parsing our input into this structure. <em>This was very tedious and error prone</em>. There are lots of potential foot guns here.</p>
<ul>
<li>The stacks are &quot;columns&quot; in the input but we would much rather they were in &quot;rows&quot;.</li>
<li>There are many symbols we don't want.</li>
<li>The instructions are 1-indexed, but we would rather have 0-indexing.</li>
</ul>
<p>The neatest way I found to do the stacks was as follows:</p>
<pre class="language-ts"><code class="language-ts">stackLines<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">=></span><br>	line<br>		<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><br>		<span class="token comment">// Fetch only the relevant input columns</span><br>		<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=></span> i <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><br>		<span class="token comment">// Push only the non-empty items to their columns</span><br>		<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=></span> char <span class="token operator">!==</span> <span class="token string">" "</span> <span class="token operator">&amp;&amp;</span> stacks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Note in particular the modulo: <code>i % 4 === 1</code>. This retrieves the value in the input column at index 1 and then ever 4th column after that. This lines up exactly with the character labels for the crates. Some positions are empty however, and so we also need to skip those rather than push empty symbols onto our internal stacks data structure.</p>
<p>I use a similar code pattern for the instruction parsing:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> instructions <span class="token operator">=</span> instructionLines<br>	<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">=></span><br>		line<br>			<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><br>			<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=></span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><br>			<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">parseInt</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><br>	<span class="token punctuation">)</span><br>	<span class="token comment">// -1 to transform from 1-index to 0-index</span><br>	<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>qty<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> qty<span class="token punctuation">,</span> from<span class="token operator">:</span> from <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> to<span class="token operator">:</span> to <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Seriously... that's the hard stuff done ðŸ˜…, everything after this point was straight forward.</p>
<p>In order to execute an instruction we need a way to apply an instruction to a given stacks state and produce a new stacks state. The gist of which is this:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> movingSlice <span class="token operator">=</span> stacks<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> qty<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">return</span> stacks<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=></span><br>	i <span class="token operator">===</span> from<br>		<span class="token operator">?</span> stack<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token comment">// Remove the moving slice from the from column</span><br>		<span class="token operator">:</span> i <span class="token operator">===</span> to<br>		<span class="token operator">?</span> <span class="token punctuation">[</span><span class="token operator">...</span>movingSlice<span class="token punctuation">,</span> <span class="token operator">...</span>stack<span class="token punctuation">]</span> <span class="token comment">// Push moving slice on top of the stack</span><br>		<span class="token operator">:</span> stack<br><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Then producing the final stacks state is a matter of applying a reduce over the instructions list and the starting state:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">return</span> instructions<br>	<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>executeInstruction<span class="token punctuation">,</span> stacks<span class="token punctuation">)</span><br>	<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> top<span class="token punctuation">)</span><br>	<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The map and join calls there handle reading the answer off the top of each stack.</p>
<p>And that's part 1!</p>
<p>Part 2 is an easy change with a copy+paste of the part 1 solution, and a one line alteration of the <code>executeInstruction</code> implementation. But for neatness I chose to pull out this behaviour difference by way of a curried function.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">solve</span> <span class="token operator">=</span><br>	<span class="token punctuation">(</span><span class="token punctuation">{</span> withMultiMove <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span> withMultiMove<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>	<span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>		<span class="token keyword">const</span> <span class="token punctuation">{</span> stacks<span class="token punctuation">,</span> instructions <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">parseFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>		<span class="token keyword">return</span> instructions<br>			<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token function">executeInstruction</span><span class="token punctuation">(</span><span class="token punctuation">{</span> withMultiMove <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stacks<span class="token punctuation">)</span><br>			<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> top<span class="token punctuation">)</span><br>			<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>This then gives me the power to create my part 1 solver and part 2 solver using this same curried function:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> solvePart1 <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> withMultiMove<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">export</span> <span class="token keyword">const</span> solvePart2 <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> withMultiMove<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://github.com/fildon/AdventOfCode2022/blob/main/src/05-supply-stacks/solutions.ts">Full Day 05 Source Code</a></p>
</details>
<h2 id="day-06-tuning-trouble" tabindex="-1"><a class="direct-link" href="#day-06-tuning-trouble" aria-hidden="true">#</a> Day 06: Tuning Trouble</h2>
<p><a href="https://adventofcode.com/2022/day/6">Day 06 Puzzle Text</a></p>
<p>The Elves have given us a handheld communication device. It is receiving a stream of data, but we need to identify start-of-packet markers in the stream.</p>
<details>
  <summary><strong>[Click to expand]</strong> my approach and solution</summary>
<p>Part 1 requires us to find the first occurance of 4 adjacent unique symbols. Actually counting and tracking uniqueness among four symbols would be tedious, but there is a quick trick for this: put them all in a Set and confirm that the Set has four members. If any were duplicates then the Set's size will be less than four. Now all we have to do is scan over the input with this approach, and return the first match:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> solvePart1 <span class="token operator">=</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">const</span> datastream <span class="token operator">=</span> <span class="token function">getInput</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> datastream<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>		<span class="token keyword">if</span> <span class="token punctuation">(</span><br>			<span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><br>			<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size <span class="token operator">===</span> <span class="token number">4</span><br>		<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>			<span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>		<span class="token punctuation">}</span><br>	<span class="token punctuation">}</span><br><br>	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"No marker found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>When I wrote this, I recognised that hard-coding it for a window size of 4 could be a problem, and I assumed that part 2 would force me to drastically rethink this approach. But no! The only change for part 2 is that the window is now length 14. Out of some dumb stubbornness I copied my part 1 approach but just hardcoded a longer window ðŸ™ˆ</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> solvePart2 <span class="token operator">=</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">const</span> datastream <span class="token operator">=</span> <span class="token function">getInput</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> datastream<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>		<span class="token keyword">if</span> <span class="token punctuation">(</span><br>			<span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>				datastream<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><br>			<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size <span class="token operator">===</span> <span class="token number">14</span><br>		<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>			<span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>		<span class="token punctuation">}</span><br>	<span class="token punctuation">}</span><br><br>	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"No marker found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>It ain't pretty or elegant, but it works ðŸ˜…</p>
<p><a href="https://github.com/fildon/AdventOfCode2022/blob/main/src/06-tuning-trouble/solutions.ts">Full Day 06 Source Code</a></p>
</details>
<h2 id="day-07-no-space-left-on-device" tabindex="-1"><a class="direct-link" href="#day-07-no-space-left-on-device" aria-hidden="true">#</a> Day 07: No Space Left On Device</h2>
<p><a href="https://adventofcode.com/2022/day/7">Day 07 Puzzle Text</a></p>
<p>Our handheld device is running out of space! We'll need to inspect the file system to identify where storage is getting used up.</p>
<details>
  <summary><strong>[Click to expand]</strong> my approach and solution</summary>
<p>A traditional file system is best modelled as a Tree datastructure. The fundamental property of a Tree is that it contains a root &quot;Node&quot; and any given Node can contain child Nodes. We can state this up front in our type declarations:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">FileMeta</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>	name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span><br>	size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name">Directory</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>	name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span><br>	parent<span class="token operator">?</span><span class="token operator">:</span> Directory<span class="token punctuation">;</span><br>	files<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>FileMeta<span class="token operator">></span><span class="token punctuation">;</span><br>	subDirectories<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Directory<span class="token operator">></span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Note I also include an <em>optional</em> parent property on each <code>Directory</code>. Every directory has a parent except for the Root which has no parent. An alternative approach to this would be for the Root node's parent to be itself, although I found implementing it that way to be more hassle than it is worth.</p>
<p>Now that we have this datastructure, we must populate it with our input data. For this we can run a reducer over our input instructions. Our starting state is an initially empty Root directory. The only additional trick I used was to include a reference to the current working directory in the state a pass through the reducer. So whereas 'file' and 'dir' inputs insert new information to our growing file system, 'cd' inputs modify our current working directory.</p>
<p>Next we require a measure of the size of each directory. The size of a directory is the size of its files plus the sizes of its subdirectories. Since this is a property that depends on children of the same type, this is a natural fit for recursion:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Given a directory annotates it with a size.<br> *<br> * Runs recursively down through all children.<br> */</span><br><span class="token keyword">const</span> measureDirectory <span class="token operator">=</span> <span class="token punctuation">(</span>dir<span class="token operator">:</span> Directory<span class="token punctuation">)</span><span class="token operator">:</span> SizedDirectory <span class="token operator">=></span> <span class="token punctuation">{</span><br>	<span class="token keyword">const</span> measuredSubDirectories <span class="token operator">=</span> dir<span class="token punctuation">.</span>subDirectories<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>measureDirectory<span class="token punctuation">)</span><span class="token punctuation">;</span><br>	<span class="token keyword">return</span> <span class="token punctuation">{</span><br>		<span class="token operator">...</span>dir<span class="token punctuation">,</span><br>		subDirectories<span class="token operator">:</span> measuredSubDirectories<span class="token punctuation">,</span><br>		size<span class="token operator">:</span><br>			dir<span class="token punctuation">.</span>files<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> <span class="token punctuation">{</span> size <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> acc <span class="token operator">+</span> size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span><br>			measuredSubDirectories<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> <span class="token punctuation">{</span> size <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> acc <span class="token operator">+</span> size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>	<span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>The only other utility I needed was a way to enumerate all directories anywhere in the tree. This is equivalent to asking for a <a href="https://en.wikipedia.org/wiki/Tree_traversal">tree traversal</a>. I implemented a depth-first preorder traversal like so:</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Recursively flatten the directory hierarchy to a simple list<br> */</span><br><span class="token keyword">const</span> flattenDirectories <span class="token operator">=</span> <span class="token punctuation">(</span>dir<span class="token operator">:</span> SizedDirectory<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>SizedDirectory<span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">[</span><br>	dir<span class="token punctuation">,</span><br>	<span class="token operator">...</span>dir<span class="token punctuation">.</span>subDirectories<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>flattenDirectories<span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>With our data structure built and these utilities in hand, the answers to both part 1 and part 2 are easy to query.</p>
<p><a href="https://github.com/fildon/AdventOfCode2022/blob/main/src/07-no-space-left-on-device/solutions.ts">Full Day 07 Source Code</a></p>
</details>

</article>
  </body>
</html>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulating Dice</title>
    <meta name="description" content="Mapping from one die size to another.">
    <link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/prism.css">
  </head>
  <body>
    <header>
      <h1 class="home">
        <a href="/">Rupert &#39;fildon&#39; McKay</a>
      </h1>
    </header>
    <article>
  <h2>Simulating Dice</h2>
  <p>In this post I will demonstrate two approaches for simulating rolls of a die of a given size, using only rolls of a die of a different size.</p>
<p>Throughout this post I will use <code>dn</code> terminology to refer to a die of size <code>n</code>. For example a <code>d6</code> refers to the classic six-sided die.</p>
<h2 id="using-base-number-conversion" tabindex="-1"><a class="direct-link" href="#using-base-number-conversion" aria-hidden="true">#</a> Using base number conversion</h2>
<p>Given an input die of size <code>n</code> and a target die of size <code>m</code>, this approach works by expanding the output space of the <code>dn</code> by rolling it repeated times, and interpreting the rolls in base <code>n</code> mod <code>m</code>. Some rolls however must be discarded to prevent bias in the outcomes.</p>
<p>To present this approach, I will start with some small examples before building up to a fully generalized algorithm.</p>
<h3 id="simulating-a-d6-using-repeated-coin-flips" tabindex="-1"><a class="direct-link" href="#simulating-a-d6-using-repeated-coin-flips" aria-hidden="true">#</a> Simulating a d6 using repeated coin flips</h3>
<p>Given a coin, we can flip it as many times as necessary for the number of outcomes to exceed the target number.</p>
<p>For a d6, we would need to flip the coin at least 3 times to produce more than 6 outcomes. If we only flipped 2 times, we could only output 4 outcomes. At 3 flips we can output 8 outcomes. Given that we have 8 outcomes, we need to discard 2.</p>
<p>Here is one scheme for doing that:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>HHH</td>
<td>1</td>
</tr>
<tr>
<td>HHT</td>
<td>2</td>
</tr>
<tr>
<td>HTH</td>
<td>3</td>
</tr>
<tr>
<td>HTT</td>
<td>4</td>
</tr>
<tr>
<td>THH</td>
<td>5</td>
</tr>
<tr>
<td>THT</td>
<td>6</td>
</tr>
<tr>
<td>TTH</td>
<td>DISCARD</td>
</tr>
<tr>
<td>TTT</td>
<td>DISCARD</td>
</tr>
</tbody>
</table>
<p>Note that the ordering here is arbitrary, but I have used binary ordering, treating <code>H</code> as <code>0</code> and <code>T</code> as <code>1</code>. Although arbitrary, this ordering will prove convenient for generalization to other die sizes.</p>
<p>Additionally notice that in this case both of the discarded results start with <code>TT</code>, so we can restart after only the second flip if we have seen <code>TT</code> so far.</p>
<p>We can combine the above two notes to produce a method of arriving at results without needing a lookup table:</p>
<ul>
<li>Flip a coin twice</li>
<li>If the flips were <code>TT</code>, discard and restart</li>
<li>Otherwise flip a third time</li>
<li>Treating <code>H</code> as <code>0</code> and <code>T</code> as <code>1</code>, read the flip outcomes as a binary number and add 1.</li>
</ul>
<h3 id="simulating-a-d6-with-a-d4" tabindex="-1"><a class="direct-link" href="#simulating-a-d6-with-a-d4" aria-hidden="true">#</a> Simulating a d6 with a d4</h3>
<p>The above method of using a coin is equivalent to repeated use of a d2. <em>A coin is a d2</em>. We can extend this method to any other die size.</p>
<p>With a d4, we need two rolls to produce a large enough outcome space to simulate at least 6 results. The outcome space is much larger than we need though, having 16 outcomes.</p>
<p>But we can map a given target result to multiple rows in our table, like so:</p>
<table>
<thead>
<tr>
<th>First roll</th>
<th>Second Roll</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>DISCARD</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>DISCARD</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>DISCARD</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>DISCARD</td>
</tr>
</tbody>
</table>
<p>Note as before that we have an opportunity to terminate early. In this case when the first roll is a <code>4</code>.</p>
<p>In order to produce a result without a lookup table we can use the same approach as before, but instead of interpreting <code>d2</code> rolls in binary, we instead interpret <code>d4</code> rolls in base 4, but also needing to take care to adjust for out by one errors caused by our base number system starting at 0, but the numbers on our dice conventionally starting at 1.</p>
<p>Precisely, one must follow these steps:</p>
<ul>
<li>Roll a d4.</li>
<li>If the outcome was <code>4</code>, discard and restart.</li>
<li>Roll the d4 a second time.</li>
<li>Subtract one from both outcomes.</li>
<li>Concatenate the two results and read as a base-4 number.</li>
<li>The computed value at this point will be between <code>0</code> and <code>11</code>.</li>
<li>Add 1 to this value and then apply <code>mod 6</code>.</li>
</ul>
<p>We can now extract from this a pattern to this process, in which any die can simulate any other die.</p>
<p>Given some pair of naturals <code>n</code> and <code>m</code>, We can simulate a <code>dm</code> using a <code>dn</code> as follows:</p>
<ul>
<li>Find the smallest natural <code>k</code> such that <code>n^k &gt;= m</code>.</li>
<li>Roll the <code>dn</code> repeatedly, <code>k</code> times.</li>
<li>Read the rolls as digits of a base <code>n</code> number.</li>
<li>Discard values greater than the largest multiple of <code>n</code> that is less than or equal to <code>m</code>.</li>
<li>Mod the result by <code>m</code> and add 1.</li>
</ul>
<p>See below for an implementation of this process in TypeScript.</p>
<details>
<summary><strong>[Click to expand]</strong> Implementation</summary>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Given `n`, simulate rolling a `dn` once.<br> *<br> * The possible outcomes are the set of naturals from 1 to n inclusive.<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> <span class="token function-variable function">produceOneResult</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> repeatCount<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> rollResults <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>repeatCount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">d</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// This reads the results as a single number in base `n`</span><br>  <span class="token keyword">const</span> result <span class="token operator">=</span> rollResults<br>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>roll<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>roll <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n <span class="token operator">**</span> <span class="token punctuation">(</span>repeatCount <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Given a `dn`, simulate the outcomes of a `dm`<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">simulateMwithN</span> <span class="token operator">=</span> <span class="token punctuation">(</span>m<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token comment">/**<br>   * `repeatCount` is the number of times we will need to roll the smaller die.<br>   */</span><br>  <span class="token keyword">const</span> repeatCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">/</span> Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">/**<br>   * The maximum valid result is the largest multiple of n that is<br>   * less than or equal to the size of our target space<br>   */</span><br>  <span class="token keyword">const</span> maxValidResult <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">**</span> repeatCount <span class="token operator">/</span> m<span class="token punctuation">)</span> <span class="token operator">*</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> result<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>  <span class="token keyword">do</span> <span class="token punctuation">{</span><br>    result <span class="token operator">=</span> <span class="token function">produceOneResult</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> repeatCount<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>result <span class="token operator">></span> maxValidResult<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span>result <span class="token operator">%</span> m<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token function">simulateMwithN</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</details>
<p><a href="https://www.typescriptlang.org/play?ssl=30&amp;ssc=9&amp;pln=30&amp;pc=23#code/PQKhCgAIUhxBLAbgUwHaQAaowGkgZ3gFsBXAGwEMAXZSAJwHsyz5UBzSCzAE20gdQBjZADooEaJAAqAC1oAHBvkIAjMrQYkqghkWT5OdWlTkFkVfgDNIqaiToUyBy4yKQAjJCoMbkVoLISQhQxaGBwHVR8C25IAF5IAApUAC4bEiIVZDoASniAPkgAWWoZEUsyBgY6ZMkSkxEHVG5dRJy8gGoPAG5wCIFoyHlGbhJhAHlUZAAlfXILBOS01AysujwjeWRqAGFNVCpl1ey8uMKAbyhISMHGZln8eYMEqYB3SABBOgcAT0TN7ZUPYkA45crwZiJAAMYKIFHkiTaBUg3GS7V6V2AwGkMngBiMFG4BhMtCMjzIVAMFCpBFYbHU6Uy2T86BU1NoWAwVxuFjJ83i9CYZAeTyukEgIjhCP+Qrw8FOhRlzEgAFoPHkYOgwEkAbt9hY1fBVeqcmKJUZRsJERQ8CoFZxIF0VHgYRjxUYqPZ0HyKb0AL4Y0ASGAIFDoLgYXi4WmkSg0LymTTaXT6KwOyNELlhfpRCyEWPUZBFV7wEwAOQFiSIRyZ6xsNbW9su4qDYpgGF1QP1GD8xNMK1raaoxFTr1oJeVU2QsW8guVJIIcOYzO48FEbfC4p59GQWz1IIWxVKImEEMS9TKlTYVby2IvIivaJyvRbYDbONocIAHsQMpBEI48CxD6Fh4gmtCUHQbD6BYsbDvIDIMNY6AmNQvaQOoygJhQ6DVJAyAAI4kI4Xg+EQG7cgMsEUF+ABqgHcCKFICveFRVDUWowJ2wIHJA2JEBqkBuGq7huhh5g7uShyMmsL4oj4zbipJ-IJMMDCWsgkwzHMFLJBsu6AjxVDPlcfqQK8uIMv8OkWIU370SwjE2SZVwel6Oo2ZAACkQmdD04ABn0raSB8XgwUOpirtEdDwCoWjwAIaZcPm5CFrEq7COI4TbjQgwvMg7xfL8iTuFCZUwuCkIVVKiL2ilcZFiW5aJAAbHgAAs7SNNOYzINagiCHggj2LkyKKfA1iJAAhAA2u4OAAEw4AAzDg7U4AArDgLUALoiP4gTcPoiTDd87SQIp4omIw7xvJAACi3zVIkGAAJKoABjlzmQykUmkAAk5ynXQfoYKa4p+n07rmO55wiPDFADXgM3AztaSI4IKMjZwBjuDtjoeJDfp4Ip7hpFCOBXAt5OU+Ky001c7UM+KG3M5ALXkwFpo5vgTCiI+uXGeAQA">Try in the TypeScript Playground</a></p>
<h2 id="using-recursive-unit-interval-segmentation" tabindex="-1"><a class="direct-link" href="#using-recursive-unit-interval-segmentation" aria-hidden="true">#</a> Using recursive unit interval segmentation</h2>
<p>Given an input die of size <code>n</code> and a target die of size <code>m</code>, this approach works by mapping to and from the unit interval. First segment the unit interval by <code>m</code>. Then treat rolls of the <code>dn</code> as &quot;narrowing in&quot; on a range of the unit line segment. We start from a range inclusive of the whole unit line segment: <code>0</code> to <code>1</code>. Then for example we can treat a roll of a <code>1</code> on a <code>d4</code> as narrowing from the range <code>0-1</code> to <code>0-1/4</code>. If we rolled at again and it came up <code>2</code> we would then narrow to the second quarter of the current range, i.e. <code>0-1/4</code> to <code>1/16-2/16</code>. At each stage we can check whether the current range fits entirely within a single 'segment' of the output die. If so we output the value on the target die associated with the segment. Otherwise we continue narrowing.</p>
<p>Let's show a complete example to demonstrate.</p>
<p>Given an input <code>d4</code> and target <code>d20</code>.</p>
<p>The target segments are 20 equal sized segments on the unit interval.</p>
<p>The current input range is the full <code>0-1</code>.</p>
<p>The first roll of the <code>d4</code> yields a <code>3</code>. The current input range is narrowed to <code>2/4-3/4</code>. The current viable output values are <code>11-15</code>. We need to narrow further.</p>
<p>The second roll of the <code>d4</code> yields a <code>1</code>. The current input range is narrowed to <code>8/16-9/16</code>. The current viable output values are <code>11-12</code>. We need to narrow further.</p>
<p>The third roll of the <code>d4</code> yields a <code>4</code>. The current input range is narrowed to <code>35/64-36/64</code>. The current viable output values are <code>12</code>. We halt with the output <code>12</code>.</p>
<p>See below for an implementation of this process in TypeScript:</p>
<details>
<summary><strong>[Click to expand]</strong> Implementation</summary>
<pre class="language-ts"><code class="language-ts"><span class="token comment">/**<br> * Represents a range on the unit interval<br> */</span><br><span class="token keyword">type</span> <span class="token class-name">Interval</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Given `n`, simulate rolling a `dn` once.<br> *<br> * The possible outcomes are the set of naturals from 1 to n inclusive.<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Let the unit interval be segmented into `m` segments of equal size,<br> * label the segments from 1 to `m`.<br> *<br> * Then given some `n` on the unit interval, output which segment of `m` it belongs to.<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">fromUnitNtoSegmentsM</span> <span class="token operator">=</span> <span class="token punctuation">(</span>m<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>n <span class="token operator">*</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Given a die, map a single result to the unit interval<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">fromDNtoInterval</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> dieResult <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">const</span> lowerBound <span class="token operator">=</span> <span class="token punctuation">(</span>dieResult <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> upperBound <span class="token operator">=</span> lowerBound <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">/</span> n<span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> <span class="token punctuation">[</span>lowerBound<span class="token punctuation">,</span> upperBound<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Given an interval and a die size,<br> * narrow the interval using a single role of the die<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">narrowIntervalWithDN</span> <span class="token operator">=</span><br>  <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>  <span class="token punctuation">(</span>interval<span class="token operator">:</span> Interval<span class="token punctuation">)</span><span class="token operator">:</span> Interval <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token comment">// This generates a new unit interval</span><br>    <span class="token keyword">const</span> <span class="token punctuation">[</span>innerLower<span class="token punctuation">,</span> innerUpper<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fromDNtoInterval</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// But we need to map it into our existing interval</span><br>    <span class="token keyword">const</span> currentIntervalSize <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">const</span> newLowerBound <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> innerLower <span class="token operator">*</span> currentIntervalSize<span class="token punctuation">;</span><br>    <span class="token keyword">const</span> newUpperBound <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> innerUpper <span class="token operator">*</span> currentIntervalSize<span class="token punctuation">;</span><br><br>    <span class="token keyword">return</span> <span class="token punctuation">[</span>newLowerBound<span class="token punctuation">,</span> newUpperBound<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * Given a `dn`, simulate the outcomes of a `dm`<br> */</span><br><span class="token keyword">const</span> <span class="token function-variable function">simulateMwithN</span> <span class="token operator">=</span> <span class="token punctuation">(</span>m<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token comment">// We'll use a tuple to track a range on the unit interval</span><br>  <span class="token keyword">let</span> interval<span class="token operator">:</span> Interval <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">const</span> mapToDM <span class="token operator">=</span> <span class="token function">fromUnitNtoSegmentsM</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> mapFromDN <span class="token operator">=</span> <span class="token function">narrowIntervalWithDN</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// In this loop we repeatedly narrow our output interval</span><br>  <span class="token comment">// Until its lower and upper bounds fit within the same segment of `dm`</span><br>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">mapToDM</span><span class="token punctuation">(</span>interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token function">mapToDM</span><span class="token punctuation">(</span>interval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    interval <span class="token operator">=</span> <span class="token function">mapFromDN</span><span class="token punctuation">(</span>interval<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">return</span> <span class="token function">mapToDM</span><span class="token punctuation">(</span>interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * A test of the distribution of a simulated dice<br> *<br> * Outputs a record where each key is a die result,<br> * and each value is how often that result occured<br> */</span><br><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">simulateMwithN</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">reduce</span><span class="token generic class-name"><span class="token operator">&lt;</span>Record<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><br>    <span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>acc<span class="token punctuation">,</span> <span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span>acc<span class="token punctuation">[</span>curr<span class="token punctuation">]</span> <span class="token operator">??</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">{</span><span class="token punctuation">}</span><br>  <span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * If the test is successful, each value should be roughly equal<br> */</span><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</details>
<p><a href="https://www.typescriptlang.org/play?#code/PQKhCgAIUglBTADgJ3gZ3gOwC5sgQ0mX0wHN5IB7TSbACwoFdMBLbSFneZAN3wBsoIYOGwBPRBQCSXXgMgBeSAG1MjALYAjbgBpIardwC64cKAjRIAcRY8skAAaYHetC3WN++bBWSV+-JykBI4AJs5UmADG8AB0QkKQACoMkIiUaG6a-BSUjNhRlOroBKi0qRjslABm+t6MxPx41X7qkACMtJT6HNH8jG528dAihZho7KGKkAAUmABc+hrayACUigB8kACy3nSx1fyUlMhzlrv0scSYoUUzq+sA1B0A3KbmiQAy8Oz0TKzsTg+OT8SDaSAYUjFLhTIHdBzqBwQ+BQrC4Ki1eAAR0Y8jcAC94DpEl5tKC-sjUThmq0Ol1HIjhjBEil7KRbPY0EUKE4kdRyv82L1gXx+Ho8thEPlIAB3OgsKJ0SnQqq1BFIoVk6ikPDYShM0bUCaQFpFACqAIAcnqAMoolVobbTGbqRYGFbrBRbOZu5bcT1bADeUA4tTOCgjkAADOtUNgGjR2m9IEQfgmdntYjEWPwzjB1Ks3gBfd5gRI2Ow0QihFhEyDqfCIEJuMg5VNoTy-boU5hCoHcUVCQ3jdim9QAEWtlBkIvkSh9S0Ma02kGDKbGxpr8AQHf47CUoTmhdM66N7COMu4ACE8jdnVud53IABaDrrGAzTrAfTH08jyCMIgkjIDezBTEoF7XreUzPJ+kDfpgx4hnG6bKJBIHQXogHAaBNxGMWpYWDAFb2CQwoDvIJBTNWtYQiwhLEpYmD4MgfgygK5EggBLbBIQPFtn4bY1BxW5DuAG7sMxrGUDKM4UfwADqbB0JOzoLIuHorjM-YgosckgqsemyKKK5rvB34pCweDkJg3DeCUhC2exvaAsZAghhJKicLZyCfDJui9D5ZpAcY0xjpOer6aKR5vCGwDfle0qXvo8DwFMer1o2HCuRleTIJA8AAB5WdgQScYOf7GlEDSoDgUUCDa9EUEoOmiso7RGC+5UCMoUb4R5Z4pTKfmXhhYHTK1PV9ZAsHedwI3cJY1WsWi9X8I1hK-pAnlOcFOHQRNbn8L1nWzZgQUhflMDLbV2BrRt8BISmKHIDQqjwMN-ljTcei7ZduGhP1JZmGWlgkVWYTOK47iePZHESoUxR4MJhAOKEiJiZ5bgeF4PjbDKymWs6roaQF6nuv6plxd+CnwAA5AE3EUIQ8aIG2GXYMQUQANYhNc5CRBxLndYIKY5Dl8lGbOoJKL1egdbFlXsA2iBJJQ45OkoY4WmwU52lSuDbC6W2eSrABirSqUoUlsWtSn0JOMUnuZkAyOUVmQEclBNslqCSPZoT8GIdTSexeVUPkUoSyC1OQBapWgmweDoQQd7YYtmjQc0QoE-QnAcWg+DFMqaIYmEGMpnKOYUC6jZqxr2lHSd6wAISRir9dG5Nx0dQ8q4him3fTObluWo30tbcDz1pq9mWq+rXdN31x5FrFHyWAAgrQ6CqiJJXICwmj5Cw-Io3ROMB5ANYxIkiQAPKR-keCEKghTIFMcrcBQ8D4IqkDc-AYOHsaK+HQJ2RiMAqIFV-kqUUjAKAezoDJDEPgaD0G8O2J8lAojLTSpjQaPhjTWw+pADerF8BiE-FGahMYQwHBzLmWhKZYgqxmPcFc2NYZ41znQMeAA2PQAAWB4dDUChEYDEAAPAgN+oRJEU2QL9P0yANgbBmAPWYv8oh6BugGWYgZYiGK0XoZQN0jCLBmFo0xNVOoAH5bHRieB0IsqxGIplXCWFMSF14wCkLUCkhDAR4A7Dg9AaBqieD0D-P+cCKBoCQZ4KY4I-CMFIHQIOBUcTuRGOJI0-g4hHFIDMQJx4gA">Try in the TypeScript Playground</a></p>
<h2 id="comparisons" tabindex="-1"><a class="direct-link" href="#comparisons" aria-hidden="true">#</a> Comparisons</h2>
<p>Both approaches could theoretically <em>never halt</em>. In the first approach, we might always hit a DISCARD result. In the second approach we might always narrow in on a segment that straddles the boundary between two possible output values. However in practice the probability of this happening for either approach tends to zero for sufficiently many rolls of the input die.</p>
<p>One might also consider the practicality of either approach. In the presence of a computer there are much more convenient methods for simulating a die. However in the absence, the first approach can be somewhat pre-computed by drawing up lookup tables for a given input die (such as the ubiquitous d6) and a selection of output die.</p>
<p>I can't find a comparative advantage to the second approach compared to the first... and yet I can't help but shake some gut feeling of preference for it. Something about &quot;zooming in&quot; on the unit segment appeals to me.</p>
<p>That's all for this post.</p>
<p>Take care,</p>
<p>Rupert</p>

</article>
    <pre aria-hidden="true" class="morse">
█ ███ █
███ ███
    </pre>
  </body>
</html>
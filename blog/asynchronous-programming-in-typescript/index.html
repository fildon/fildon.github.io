<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Asynchronous Programming in TypeScript.</title>
		<meta name="description" content="async/await vs promises.">
		<link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico">
		<link rel="stylesheet" href="/static/styles.css">
		<link rel="stylesheet" href="/static/prism.css">
		<meta
			property="og:description"
			content="async/await vs promises."
		/>
		<meta
			property="og:image"
			content="https://raw.githubusercontent.com/fildon/train-ride/main/train-ride.png"
		/>
		<meta property="og:image:type" content="image/png" />
		<meta property="og:image:width" content="1280" />
		<meta property="og:image:height" content="640" />
		<meta name="twitter:card" content="summary_large_image" />
		<meta property="twitter:domain" content="rupertmckay.com" />
		<meta property="twitter:url" content="https://rupertmckay.com" />
		<meta name="twitter:title" content="Asynchronous Programming in TypeScript." />
		<meta
			name="twitter:description"
			content="async/await vs promises."
		/>
		<meta
			name="twitter:image"
			content="https://raw.githubusercontent.com/fildon/train-ride/main/train-ride.png"
		/>
	</head>
	<body>
		<header class="horizontal-spread">
			<img
				src="../../static/headshot.jpeg"
				alt="Headshot of Rupert"
				class="rounded wonky"
				height="64"
				width="64"
			/>
			<h1><a href="/">Rupert McKay</a></h1>
		</header>
		<section class="full-width banner">
			<div>
				<h2>About</h2>
				<p>
					I am Rupert Foggo McKay. I live and work in the Netherlands.
					I work at <a href="https://odido.nl/">Odido.nl</a> as a Principal Software Engineer.
					I write blog posts on esoteric topics from time to time.
				</p>
			</div>
			<address>
				<a href="/blog/">Blog</a>
				<a href="https://github.com/fildon/">GitHub</a>
				<a rel="me" href="https://strangeobject.space/@fildon">Masto</a>
				<a href="mailto:rupert@rupertmckay.com">Email</a>
				<a href="./feed.xml">RSS</a>
			</address>
		</section>
		<article>
	<h1>Asynchronous Programming in TypeScript.</h1>
	<span>Posted: <date datetime="Mon May 16 2022 00:00:00 GMT+0000 (Coordinated Universal Time)">16 May 2022</date></span>
	<p>Key takeaways:</p>
<ul>
<li>Promises can run code <em>after some other code has completed</em></li>
<li><code>async/await</code> is just syntactic sugar</li>
<li><code>Promise.all</code> is great for parallel tasks</li>
</ul>
<h2 id="what-is-a-promise" tabindex="-1"><a class="direct-link" href="#what-is-a-promise" aria-hidden="true">#</a> What is a Promise?</h2>
<p>A promise is some task that we can use to chain together later tasks.</p>
<p>For example, imagine telling your friend how to make tea. Here's one way to do it:</p>
<blockquote>
<p>Say to your friend, &quot;Boil water.&quot;</p>
<p><em>Stand next to them awkwardly, waiting for them to finish boiling water</em></p>
<p>Say to your friend, &quot;Pour the hot water into a cup and add a teabag.&quot;</p>
</blockquote>
<p>But it's usually easier to provide all the instructions right away, without having to wait:</p>
<blockquote>
<p>Say to your friend, &quot;Boil water... <em>and then when you are done with that</em> you should pour it into a cup and add a teabag&quot;.</p>
</blockquote>
<p>With this second approach, we don't have to wait around watching our friend boil water and can go off and do something else. Sooner or later, our friend will complete the whole task and have a lovely cup of tea.</p>
<p>The key insight here is recognizing how we can give instructions that will only be executed <em>after some other instruction has been completed</em>. Promises are the mechanism by which we provide instructions to execute later.</p>
<p>In the language of promises, we could say that &quot;boil water&quot; is a function that returns a <em>Promise of boiled water</em> and we chain on a <code>then</code> to do something with that boiled water when it is ready.</p>
<h2 id="promise-syntax" tabindex="-1"><a class="direct-link" href="#promise-syntax" aria-hidden="true">#</a> Promise Syntax</h2>
<p>Lets look at a more practical programming example. Imagine we have a website where users can 'favourite' products. We might store user information in a database, which can only be accessed <em>asynchronously</em>. To get a user's wishlisted products, we might have some code that looks like:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> getProductWishlistForUser <span class="token operator">=</span> <span class="token punctuation">(</span>userId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">Array</span><span class="token operator">&lt;</span>Product<span class="token operator">>></span> <span class="token operator">=></span><br>  <span class="token function">fetchUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token operator">=></span> user<span class="token punctuation">.</span>wishlist<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><code>fetchUser</code> is some function that accesses our database. It might be rather slow, or perhaps need to run over a network request, so it can't return <em>synchronously</em>. Instead, it returns a <em>promise of a user</em>, or in TypeScript syntax, that would be <code>Promise&lt;User&gt;</code>. To do something with that <code>user</code> when the <code>Promise</code> is ready, we use <code>.then</code>. Every <code>Promise</code> resolves to some result eventually, and the <code>.then</code> method is how you indicate what you want to do with that result when it is ready. In this example, we are saying, &quot;get the user <em>and then</em> return just the wishlist on that user.</p>
<h2 id="async-await-syntax" tabindex="-1"><a class="direct-link" href="#async-await-syntax" aria-hidden="true">#</a> Async/Await Syntax</h2>
<p>The <code>async/await</code> syntax is a more recent addition to JavaScript. Here's that same example but rewritten using <code>async/await</code>:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> getProductWishlistForUser <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><br>  userId<span class="token operator">:</span> <span class="token builtin">string</span><br><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">Array</span><span class="token operator">&lt;</span>Product<span class="token operator">>></span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> user<span class="token punctuation">.</span>wishlist<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Some people find this syntax easier to read. The <code>await</code> keyword converts a <code>Promise</code> into its resolved type. In this case, turning <code>Promise&lt;User&gt;</code> into just <code>User</code>. We can then access the <code>User</code> object directly without needing to be inside a <code>.then</code> callback. But it is very important to understand that these two examples will be executed in <em>exactly the same way</em>. Notice how the return type of this function is still a <code>Promise</code>. Every <code>async</code> function is wrapped in a <code>Promise</code> automatically. This can be occasionally surprising and misleading. But if you understand that fundamentally <code>async/await</code> is just syntactic sugar for promises, then you won't be confused.</p>
<h2 id="parallelism" tabindex="-1"><a class="direct-link" href="#parallelism" aria-hidden="true">#</a> Parallelism</h2>
<p>A common mistake I see with <code>async/await</code> is waiting for promises to resolve one after the other, even when they could be running in parallel. Consider this example:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">getAllUsersAndProducts</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchAllUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> products <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchAllProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> <span class="token punctuation">{</span> users<span class="token punctuation">,</span> products <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>The problem here is that we fully wait for the user request to complete before even starting the product request. If I had to boil two pots of water, I wouldn't wait for one to begin boiling before starting the second one, I would start both at the same time. There isn't a direct way to do this with the <code>async/await</code> syntax, but we can achieve this with <code>Promise.all</code>:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">getAllUsersAndProducts</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">fetchAllUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fetchAllProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><br>    <span class="token punctuation">(</span><span class="token punctuation">[</span>users<span class="token punctuation">,</span> products<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> users<span class="token punctuation">,</span> products <span class="token punctuation">}</span><span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><code>Promise.all</code> takes an array of promises and returns a single combined promise. You can use this to start multiple asynchronous tasks at the same time, and then chain on a later task only when all the initial tasks have resolved.</p>
<p>In this case, we can expect the code to run roughly two times faster, because we are waiting for two things <em>running at the same time</em> rather than having to wait for them to finish one after the other. The benefit of this approach is even more significant when handling three or more promises that can run in parallel.</p>
<p>So for situations like this, it seems the promise syntax is the better choice.</p>
<h2 id="async-await-shared-scope" tabindex="-1"><a class="direct-link" href="#async-await-shared-scope" aria-hidden="true">#</a> Async/Await shared scope</h2>
<p>Promises aren't always better than <code>async/await</code>, however. There's one thing that <code>async/await</code> can do, which promises can only do with great difficulty. Suppose that we have an <code>orderId</code> which we can use to look up order details and also lookup details about the user that placed the order. We want to combine this information to display the user's name next to the id of the product they have ordered. We might try to do this with the following code:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">getOrderSummary</span> <span class="token operator">=</span> <span class="token punctuation">(</span>orderId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><br>    <span class="token function">fetchOrder</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><br>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span><br>      <span class="token comment">// Error on the next line because `order` is not in scope!</span><br>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> | </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>order<span class="token punctuation">.</span>productId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>But as you can see this doesn't work because each individual <code>.then</code> callback has its own isolated scope. We can't access variables in one scope from a different scope. There is a way to get around this by passing along the variable with the chained task:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">getOrderSummary</span> <span class="token operator">=</span> <span class="token punctuation">(</span>orderId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token function">fetchOrder</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>order<span class="token punctuation">,</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>order<span class="token punctuation">,</span> user<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> | </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>order<span class="token punctuation">.</span>productId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>But this is very unusual and I find very difficult to read and maintain. If however we use <code>async/await</code> instead, there is no problem at all:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">getOrderSummary</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>orderId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> order <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchOrder</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> | </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>order<span class="token punctuation">.</span>productId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Because the <code>await</code> keyword exposes the resolved value in the same scope that we start in, it is much easier to combine results from different stages of the asynchronous task.</p>
<h2 id="hybrid-getting-the-best-of-both" tabindex="-1"><a class="direct-link" href="#hybrid-getting-the-best-of-both" aria-hidden="true">#</a> Hybrid: Getting the best of both</h2>
<p>So we've seen at least one example where a <code>Promise</code> is best, and another where <code>async/await</code> is best. How can we get the best of both?</p>
<p>Since Async/Await is just syntactic sugar for promises, we can mix and match the two syntaxes together. This unlocks the power of parallel promises with <code>Promise.all</code> while also getting the shared variable scoping of <code>await</code> like so:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">getOrderDetails</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>orderId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> order <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchOrder</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>user<span class="token punctuation">,</span> product<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>    <span class="token function">fetchUser</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">fetchProductDetails</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>productId<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> `$<span class="token punctuation">{</span>order<span class="token punctuation">.</span>timestamp<span class="token punctuation">}</span> <span class="token operator">|</span> $<span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">|</span> $<span class="token punctuation">{</span>product<span class="token punctuation">.</span>name<span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>In this final example, we fetch an order by its id, then <em>in parallel</em> we fetch user and product details. We return a summary including the order, user, and product information.</p>
<h2 id="summary" tabindex="-1"><a class="direct-link" href="#summary" aria-hidden="true">#</a> Summary</h2>
<p>Many people like to argue about Promises vs. Async/Await, but in truth, they are different tools with different specialties. You should learn to understand and use both and apply each where it will be most effective.</p>
<p>Take care,</p>
<p>Rupert</p>

</article>
		<pre aria-hidden="true" class="morse">
█ ███ █
███ ███
</pre>
	</body>
</html>
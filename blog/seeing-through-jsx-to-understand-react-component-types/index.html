<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Seeing through JSX to understand React Component types</title>
		<meta name="description" content="Why you shouldn&#39;t use React.FC.">
		<link rel="canonical" href="https://rupertmckay.com/blog/seeing-through-jsx-to-understand-react-component-types/">
		<link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico">
		<link rel="stylesheet" href="/static/styles.css">
		<link rel="stylesheet" href="/static/prism.css">
		<link rel="alternate" type="application/atom+xml" title="Rupert Foggo McKay" href="/feed.xml">
		
		<!-- Open Graph / Facebook -->
		<meta property="og:type" content="article">
		<meta property="og:url" content="https://rupertmckay.com/blog/seeing-through-jsx-to-understand-react-component-types/">
		<meta property="og:site_name" content="Rupert Foggo McKay">
		<meta property="og:title" content="Seeing through JSX to understand React Component types">
		<meta property="og:description" content="Why you shouldn&#39;t use React.FC.">
		<meta property="og:image" content="https://raw.githubusercontent.com/fildon/train-ride/main/train-ride.png">
		<meta property="og:image:type" content="image/png">
		<meta property="og:image:width" content="1280">
		<meta property="og:image:height" content="640">
		
		<meta property="article:published_time" content="2021-06-27">
		<meta property="article:author" content="Rupert Foggo McKay">
		
		
		<!-- Twitter -->
		<meta name="twitter:card" content="summary_large_image">
		<meta property="twitter:domain" content="rupertmckay.com">
		<meta property="twitter:url" content="https://rupertmckay.com/blog/seeing-through-jsx-to-understand-react-component-types/">
		<meta name="twitter:title" content="Seeing through JSX to understand React Component types">
		<meta name="twitter:description" content="Why you shouldn&#39;t use React.FC.">
		<meta name="twitter:image" content="https://raw.githubusercontent.com/fildon/train-ride/main/train-ride.png">
		
		<!-- JSON-LD Structured Data -->
		
		<script type="application/ld+json">
		{
			"@context": "https://schema.org",
			"@type": "BlogPosting",
			"headline": "Seeing through JSX to understand React Component types",
			"description": "Why you shouldn&#39;t use React.FC.",
			"author": {
				"@type": "Person",
				"name": "Rupert Foggo McKay",
				"url": "https://rupertmckay.com"
			},
			"datePublished": "2021-06-27",
			"dateModified": "2021-06-27",
			"url": "https://rupertmckay.com/blog/seeing-through-jsx-to-understand-react-component-types/",
			"image": "https://raw.githubusercontent.com/fildon/train-ride/main/train-ride.png",
			"publisher": {
				"@type": "Person",
				"name": "Rupert Foggo McKay",
				"url": "https://rupertmckay.com"
			},
			"mainEntityOfPage": {
				"@type": "WebPage",
				"@id": "https://rupertmckay.com/blog/seeing-through-jsx-to-understand-react-component-types/"
			}
		}
		</script>
		
	</head>
	<body>
		<header class="horizontal-spread">
			<img src="/static/headshot.jpeg" alt="Headshot of Rupert" class="rounded wonky" height="64" width="64">
			<h1><a href="/">Rupert McKay</a></h1>
		</header>
		<section class="full-width banner">
			<div>
				<h2>About</h2>
				<p>
					I am Rupert Foggo McKay. I live and work in the Netherlands.
					I work at <a href="https://odido.nl/">Odido.nl</a> as a Principal Software Engineer.
					I write blog posts on esoteric topics from time to time.
				</p>
			</div>
			<address>
				<a href="/blog/">Blog</a>
				<a href="https://github.com/fildon/">GitHub</a>
				<a href="mailto:rupert@rupertmckay.com">Email</a>
			</address>
		</section>
		<article>
	<h1>Seeing through JSX to understand React Component types</h1>
	<date datetime="Sun Jun 27 2021 00:00:00 GMT+0000 (Coordinated Universal Time)">27 Jun 2021</date>
	<p>Here are the big takes right away:</p>
<ul>
<li>Don't use <code>React.FC</code>.</li>
<li>Explicitly type your props <em>including permitted <code>children</code> types</em>.</li>
<li>Prefer inferred return types, but <code>JSX.Element</code> if you have to.</li>
</ul>
<p>To justify these claims, we will peek behind the JSX curtain to see what's really going on.</p>
<h2 id="what-is-jsx-really" tabindex="-1"><a class="direct-link" href="#what-is-jsx-really" aria-hidden="true">#</a> What is JSX <em>really</em>?</h2>
<p><em>It is a lie.</em></p>
<p>JSX is a special kind of syntax <em>which JavaScript can't run</em>. You can see from <a href="https://facebook.github.io/jsx/">the original JSX proposal</a> that it was never intended to be something that can be run by JavaScript engines directly. Instead, it requires some transpiler to boil it down to a series of <code>createElement</code> calls, which <em>are just plain old JavaScript functions</em>. Depending on your stack, you probably do this transpilation with either <code>Babel</code> or <code>TypeScript</code>.</p>
<p><em><strong>Disclaimer</strong>: Neither Babel, TypeScript nor React have a monopoly on JSX</em>; go take a look at <a href="https://preactjs.com/">Preact</a> for example, if you haven't already.</p>
<p>To really understand this transpilation, let's inspect some examples:</p>
<p><em>I have lightly edited the Babel output for clarity</em> but you can try these with this fancy link that encodes these examples in the <a href="https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;corejs=3.6&amp;spec=false&amp;loose=false&amp;code_lz=GYVwdgxgLglg9mABACQKYBt1wBQAcBOcuAzgJSIDeAUIovqlCPkgDzG4CGSAFjACZ9UYAHwUCRYgDoAtqmLEOAc1QBfFgHp2XYQG4qKqlVCRYCRAFkQ6WAGFe6PvTDZy1WvUbNE2GrURtUaHgRXz9_NEw4RFl5JVQAXgAiAEkAcmlEDkQIez5EOGBEKG5URGJA0zBExHVhUL8WCKxouQVlJK482SK4OGra-tpGjGaYtoTE7uL6VABCfrqwjXKghEXEUn0qIA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=react&amp;prettier=false&amp;targets=&amp;version=7.14.7&amp;externalPlugins=">Babel REPL</a></p>
<pre class="language-js"><code class="language-js"><span class="token comment">// Before Babel</span>
<span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>span hidden<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// After Babel</span>
<span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">hidden</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>In this example the <code>Hello</code> component demonstrates how primitive HTML elements are converted to a <code>createElement</code> taking three arguments:</p>
<table>
<thead>
<tr>
<th>Args</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTML element name</td>
<td><code>&quot;span&quot;</code></td>
</tr>
<tr>
<td>Attributes object</td>
<td><code>{ hidden: true }</code></td>
</tr>
<tr>
<td>Children</td>
<td><code>props.message</code></td>
</tr>
</tbody>
</table>
<p>But what if we have multiple children, or reference other React components:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// Before Babel</span>
<span class="token keyword">function</span> <span class="token function">MultiChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>section<span class="token operator">></span>
      <span class="token operator">&lt;</span>Hello message<span class="token operator">=</span><span class="token string">"I'm a child of the section"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>Hello message<span class="token operator">=</span><span class="token string">"and me too"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>Hello message<span class="token operator">=</span><span class="token string">"me three!"</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>section<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// After Babel</span>
<span class="token keyword">function</span> <span class="token function">MultiChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
    <span class="token string">"section"</span><span class="token punctuation">,</span>
    <span class="token keyword">null</span><span class="token punctuation">,</span>
    React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"I'm a child of the section"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"and me too"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"me three!"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>The <code>MultiChildren</code> component is very similar but reveals a few more interesting features. Firstly, the first argument to <code>createElement</code> can be a <em>function reference</em> to another React component, which is the <code>Hello</code> component. Secondly, <code>createElement</code> can take more than three arguments to accommodate multiple children. Finally, if no attributes are provided <code>null</code> is used.</p>
<p>As an aside, have you ever wondered why you need to import <code>React</code> into a JSX file, even when you don't reference it directly? Well now you can see, it is because <em>you actually do!</em> It is just hidden behind JSX transpilation. <code>React</code> has to be in scope so that <code>createElement</code> can run.</p>
<p>At this point we should have a pretty good idea of the sorts of arguments <code>createElement</code> takes. Let's see what TypeScript has to say about it.</p>
<h2 id="typescript" tabindex="-1"><a class="direct-link" href="#typescript" aria-hidden="true">#</a> TypeScript</h2>
<p><em>The following type definitions are from <a href="https://www.npmjs.com/package/@types/react">@types/react</a> v17.0.11</em></p>
<p><code>createElement</code> has 8 overloads, but for our purposes this version is the most relevant, since it handles custom function components:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">createElement</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  type<span class="token operator">:</span> FunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> ComponentClass<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  props<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>Attributes <span class="token operator">&amp;</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>children<span class="token operator">:</span> ReactNode<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token operator">:</span> ReactElement<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre>
<p>The <code>P</code> generic type here corresponds to the <em>props</em> of the given component, which defaults to an empty object if none are provided. But other than that, there should be no surprises here. This matches exactly what we observed earlier:</p>
<ul>
<li>The first argument can be a string or a reference to a custom React component</li>
<li>The second argument is an object containing attributes and props</li>
<li>The third argument handles children (gathered from additional args as necessary)</li>
</ul>
<p>It could be very tempting at this point to see the <code>FunctionComponent</code> definition, and take that as the authority on how to type a component. But let's see what it really does:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">FunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>props<span class="token operator">:</span> PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  propTypes<span class="token operator">?</span><span class="token operator">:</span> WeakValidationMap<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  contextTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">;</span>
  defaultProps<span class="token operator">?</span><span class="token operator">:</span> Partial<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  displayName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span></span> <span class="token operator">=</span> FunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre>
<p>I have a big issue with function type definitions that are both a function <em>and also</em> take additional key-values. But I'll save that for another post. For now, though, it should be clear there is a lot of stuff in there you don't need and probably will never use. We could dive into each of these, but let's just focus on <code>PropsWithChildren</code>:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">P</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> children<span class="token operator">?</span><span class="token operator">:</span> ReactNode <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Remember that <code>P</code> is the type of props passed to our component, but in this type definition, an optional <code>children</code> parameter is added <em>whether you wanted it or not</em>.</p>
<p>In practice this silently ignores a particular bug which ought to be caught at compile time. To demonstrate this we just need a component that takes no children:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">GreetingProps</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> Greeting<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span>GreetingProps<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>span<span class="token operator">></span>Hello <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Then somewhere else in our app:</span>
<span class="token operator">&lt;</span>Greeting name<span class="token operator">=</span><span class="token string">"rupert"</span><span class="token operator">></span>good morning<span class="token operator">&lt;</span><span class="token operator">/</span>Greeting<span class="token operator">></span><span class="token punctuation">;</span></code></pre>
<p>In this example we define a component taking a single string prop <code>name</code>, and then invoke it with the string <code>rupert</code> <em>but also</em> pass the children string <code>good morning</code>. This is a mistake. Our component doesn't take or use children, and if I wrote this code I would want my IDE to tell me right away, but because we are using <code>React.FC</code> the <em>actual</em> type of props our <code>Greeting</code> accepts has been broadened to:</p>
<pre class="language-ts"><code class="language-ts"><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> children<span class="token operator">?</span><span class="token operator">:</span> React<span class="token punctuation">.</span>ReactNode <span class="token punctuation">}</span></code></pre>
<p>So there's no compile time error. On the other hand if we simply didn't use <code>React.FC</code>:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">GreetingProps</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">Greeting</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token operator">:</span> GreetingProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">&lt;</span>span<span class="token operator">></span>Hello <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// Then somewhere else in our app:</span>
<span class="token operator">&lt;</span>Greeting name<span class="token operator">=</span><span class="token string">"rupert"</span><span class="token operator">></span>good morning<span class="token operator">&lt;</span><span class="token operator">/</span>Greeting<span class="token operator">></span><span class="token punctuation">;</span></code></pre>
<p>In this case, TypeScript will correctly tell us we've made a mistake. That's a good thing. Errors should be loud and discovered at the first opportunity.</p>
<h2 id="specific-children-types" tabindex="-1"><a class="direct-link" href="#specific-children-types" aria-hidden="true">#</a> Specific Children types</h2>
<p>Hopefully, I've convinced you that if your component doesn't take children, you shouldn't use <code>React.FC</code>, but what if your component does take children? OK, well, what type of children does your component take?</p>
<p>The most common type for children is <code>ReactNode</code>. But if your component <em>has to take children</em> shouldn't you enforce that? By explicitly typing your children in the props type you define, you get that enforcement by TypeScript.</p>
<p>I've also seen components that <em>must take</em> multiple children, which we can type as <code>ReactNode[]</code>. In this case, it is a type error to pass only a single child. I think that's great!</p>
<p>Or what about a component that takes a callback as its child:</p>
<pre class="language-ts"><code class="language-ts"><span class="token operator">&lt;</span>AuthGuard<span class="token operator">></span><span class="token punctuation">(</span>readPermission<span class="token punctuation">,</span> writePermission<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Custom render function based on user permissions</span>
<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>AuthGuard<span class="token operator">></span></code></pre>
<p>In this case, we can type children as</p>
<pre class="language-ts"><code class="language-ts"><span class="token function-variable function">children</span><span class="token operator">:</span> <span class="token punctuation">(</span>readPermission<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> writePermission<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">JSX</span><span class="token punctuation">.</span>Element<span class="token punctuation">;</span></code></pre>
<p>That's certainly something I want TypeScript to have tight control over.</p>
<h2 id="default-prop-handling" tabindex="-1"><a class="direct-link" href="#default-prop-handling" aria-hidden="true">#</a> Default Prop handling</h2>
<p>One final critique I'd like to make of using <code>React.FC</code> is how it forces us to type the function, rather than the inputs and outputs directly. This leads to some surprising behavior in the destructuring of default values:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">MessageProps</span> <span class="token operator">=</span> <span class="token punctuation">{</span> message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Here TypeScript correctly tells us that 'number' is not assignable to 'string'</span>
<span class="token keyword">const</span> <span class="token function-variable function">MessageWithoutReactFC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> message <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token operator">:</span> MessageProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// However in this case it allows a mismatching default value</span>
<span class="token keyword">const</span> MessageWithReactFC<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span>MessageProps<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> message <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>TypeScript allows this in the <code>React.FC</code> case because it is implicitly defining a new type on the fly after the props object has been destructured. Inside the body of <code>MessageWithReactFC</code> the type of <code>message</code> is <code>string | number</code>. There is nothing <em>strictly</em> wrong with this, but it is very surprising behavior.</p>
<h2 id="return-types" tabindex="-1"><a class="direct-link" href="#return-types" aria-hidden="true">#</a> Return Types</h2>
<p>It is up to you what your component returns, but naturally, it has to be something that React can render. <em>Most of the time</em> the type <code>JSX.Element</code> is a good fit. Tailor this more specifically to your use case if possible.</p>
<h2 id="summary" tabindex="-1"><a class="direct-link" href="#summary" aria-hidden="true">#</a> Summary</h2>
<p>Your type system exists to tell you when you make a mistake. It should be strict enough to exclude all unwanted values, but not so strict as to exclude wanted values. Take the time to think carefully and intentionally about the types your component takes in and the types it puts out. <code>React.FC</code> is by design a very loose fit for very many kinds of components. We can and should be more specific.</p>
<ul>
<li>Don't use <code>React.FC</code>.</li>
<li>Explicitly type your props <em>including permitted <code>children</code> types</em>.</li>
<li>Prefer inferred return types, but <code>JSX.Element</code> if you have to.</li>
</ul>
<p>Take care,</p>
<p>Rupert</p>

</article>
	</body>
</html>
